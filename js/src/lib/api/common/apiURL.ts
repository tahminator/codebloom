import { UnknownApiResponse } from "@/lib/api/common/apiResponse";
import { operations, paths } from "@/lib/api/types/autogen/schema";

type MaybeParams<T> =
  keyof T extends never ? { params?: undefined } : { params: T };

type HttpMethodLower =
  | "get"
  | "post"
  | "put"
  | "delete"
  | "options"
  | "head"
  | "patch"
  | "trace";
type HttpMethodUpper = Uppercase<HttpMethodLower>;

type PathsKey = keyof paths;
type PathsMethods<TKey extends PathsKey> = paths[TKey];
type PathsMethodKey<TKey extends PathsKey> = keyof PathsMethods<TKey>;
type PathMethodResult<
  TPathKey extends PathsKey,
  TPathMethodKey extends PathsMethodKey<TPathKey>,
> = PathsMethods<TPathKey>[TPathMethodKey];

type OperationsKey = keyof operations;
type OperationsPath<TKey extends OperationsKey> = operations[TKey];

type OperationFromPathMethodResult<TResult> = {
  [K in OperationsKey]: OperationsPath<K> extends TResult ? K : never;
}[OperationsKey];

type PathParamToOperations<
  TPathKey extends PathsKey,
  TMethod extends PathsMethodKey<TPathKey>,
> = OperationFromPathMethodResult<PathMethodResult<TPathKey, TMethod>>;

type PathOperationsToPathParams<TOperationsKey extends OperationsKey> =
  OperationsPath<TOperationsKey>["parameters"]["path"];

type PathOperationsToPathQueries<TOperationsKey extends OperationsKey> =
  OperationsPath<TOperationsKey>["parameters"]["query"];

type PathOperationsToPathResponseBody<TOperationsKey extends OperationsKey> =
  Extract<
    OperationsPath<TOperationsKey>["responses"],
    { 200: unknown }
  >[200]["content"]["*/*"];

type PathOperationsToPathResponsePayload<TOperationsKey extends OperationsKey> =
  Extract<
    PathOperationsToPathResponseBody<TOperationsKey>,
    { payload: unknown }
  >["payload"];

type PathOperationsToPathRequestBody<TOperationsKey extends OperationsKey> =
  Extract<
    OperationsPath<TOperationsKey>["requestBody"],
    { content: unknown }
  >["content"]["application/json"];

/**
 * The de-facto type-safe object to fetch data from the Codebloom backend.
 * This class introspects the autogenerated schema types file that is based on 
 * the OpenAPI schema from the backend.
 *
 * @example
 * ```ts
    const { url, method, req, res } = ApiURL.create("/api/admin/user/admin/toggle", {
      method: "POST",
    });
    const response = await fetch(url, {
      method: method,
      headers: {
        "Content-Type": "application/json",
      },
      body: req({
        id: userId,
        toggleTo,
      }),
    });

    const json = res(await response.json());
 * ```
 */
export class ApiURL<
  TPathKey extends PathsKey,
  TPathMethod extends PathsMethodKey<TPathKey>,
> {
  private readonly _url: URL;
  private readonly _method: Uppercase<
    Extract<PathsMethodKey<TPathKey>, string>
  >;

  public static create<
    const TCreatePathKey extends PathsKey,
    const TCreatePathMethod extends HttpMethodUpper &
      Uppercase<Extract<PathsMethodKey<TCreatePathKey>, string>>,
  >(
    path: TCreatePathKey,
    {
      method,
      params,
      queries,
    }: {
      method?: TCreatePathMethod | PathsKey;
    } & MaybeParams<
      PathOperationsToPathParams<
        PathParamToOperations<TCreatePathKey, Lowercase<TCreatePathMethod>>
      >
    > & {
        queries?: PathOperationsToPathQueries<
          PathParamToOperations<TCreatePathKey, Lowercase<TCreatePathMethod>>
        >;
      },
  ): ApiURL<TCreatePathKey, Lowercase<TCreatePathMethod>> {
    const opt = {
      method: (method?.toLowerCase() ?? "get") as Lowercase<TCreatePathMethod> &
        HttpMethodLower,
      params: params ?? {},
      queries: queries ?? {},
    } as unknown as {
      method: Lowercase<TCreatePathMethod>;
      params: PathOperationsToPathParams<
        PathParamToOperations<TCreatePathKey, Lowercase<TCreatePathMethod>>
      >;
      queries: PathOperationsToPathQueries<
        PathParamToOperations<TCreatePathKey, Lowercase<TCreatePathMethod>>
      >;
    };

    return new ApiURL(path, opt);
  }

  private constructor(
    path: TPathKey,
    options: {
      method: PathsMethodKey<TPathKey>;
      params: PathOperationsToPathParams<
        PathParamToOperations<TPathKey, TPathMethod>
      >;
      queries: PathOperationsToPathQueries<
        PathParamToOperations<TPathKey, TPathMethod>
      >;
    },
  ) {
    const { method, params, queries } = options;
    if (typeof method === "string") {
      this._method = method.toUpperCase() as Uppercase<
        Extract<keyof PathsMethods<TPathKey>, string>
      >;
    } else {
      // never should happen, unless someone disobeys type contract
      throw Error("method passed into ApiURL is not a valid string");
    }

    let resolved: string = path;
    if (params) {
      for (const [k, v] of Object.entries(params)) {
        resolved = resolved.replace(`{${k}}`, encodeURIComponent(String(v)));
      }

      if (/\{[^}]+\}/.test(resolved)) {
        throw new Error(`Missing path params for: ${path}`);
      }
    }

    let url: URL;
    try {
      url = new URL(resolved, window.location.origin);
    } catch (e) {
      console.log(e);
      throw e;
    }

    this._url = url;

    if (!queries) {
      return;
    }

    for (const [k, v] of Object.entries(queries)) {
      if (v != null) {
        url.searchParams.set(k, String(v));
      }
    }
  }

  /**
   * Return final URL state post-creation.
   */
  get url(): URL {
    return this._url;
  }

  get method(): typeof this._method {
    return this._method;
  }

  req(
    body: PathOperationsToPathRequestBody<
      PathParamToOperations<TPathKey, TPathMethod>
    >,
  ): string {
    return JSON.stringify(body);
  }

  res(
    response: unknown,
  ): UnknownApiResponse<
    PathOperationsToPathResponsePayload<
      PathParamToOperations<TPathKey, TPathMethod>
    >
  > {
    return response as UnknownApiResponse<
      PathOperationsToPathResponsePayload<
        PathParamToOperations<TPathKey, TPathMethod>
      >
    >;
  }

  toString(): string {
    return this._url.toString();
  }
}
