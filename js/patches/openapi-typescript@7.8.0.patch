diff --git a/dist/transform/schema-object.cjs b/dist/transform/schema-object.cjs
index b8175ac46f71af118272973c3915afab63268d2f..6b996f019ed17224beb914cd148818b4bdc15241 100644
--- a/dist/transform/schema-object.cjs
+++ b/dist/transform/schema-object.cjs
@@ -41,8 +41,14 @@ function transformSchemaObjectWithComposition(schemaObject, options) {
   }
   if (Array.isArray(schemaObject.enum) && (!("type" in schemaObject) || schemaObject.type !== "object") && !("properties" in schemaObject) && !("additionalProperties" in schemaObject)) {
     if (options.ctx.enum && schemaObject.enum.every((v) => typeof v === "string" || typeof v === "number" || v === null)) {
-      let enumName = refUtils_js.parseRef(options.path ?? "").pointer.join("/");
-      enumName = enumName.replace("components/schemas", "");
+      const enumName = (() => {
+        if (schemaObject.description) {
+          return schemaObject.description;
+        }
+        let n = refUtils_js.parseRef(options.path ?? "").pointer.join("/");
+        n = n.replace("components/schemas", "");
+        return n;
+      })();
       const metadata = schemaObject.enum.map((_, i) => ({
         name: schemaObject["x-enum-varnames"]?.[i] ?? schemaObject["x-enumNames"]?.[i],
         description: schemaObject["x-enum-descriptions"]?.[i] ?? schemaObject["x-enumDescriptions"]?.[i]
@@ -401,3 +407,4 @@ function hasKey(possibleObject, key) {
 exports.default = transformSchemaObject;
 exports.transformSchemaObjectWithComposition = transformSchemaObjectWithComposition;
 //# sourceMappingURL=schema-object.cjs.map
+
diff --git a/dist/transform/schema-object.cjs.map b/dist/transform/schema-object.cjs.map
index dd7a3e50be47a83b36e26756e9eac23baaf78b75..8a8e324db9b9c33217ff7252fc8e9936a7ff7d3e 100644
--- a/dist/transform/schema-object.cjs.map
+++ b/dist/transform/schema-object.cjs.map
@@ -1 +1 @@
-{"version":3,"file":"schema-object.cjs","sources":["../../src/transform/schema-object.ts"],"sourcesContent":["import { parseRef } from \"@redocly/openapi-core/lib/ref-utils.js\";\nimport ts from \"typescript\";\nimport {\n  BOOLEAN,\n  NEVER,\n  NULL,\n  NUMBER,\n  QUESTION_TOKEN,\n  STRING,\n  UNDEFINED,\n  UNKNOWN,\n  addJSDocComment,\n  oapiRef,\n  tsArrayLiteralExpression,\n  tsEnum,\n  tsIntersection,\n  tsIsPrimitive,\n  tsLiteral,\n  tsModifiers,\n  tsNullable,\n  tsOmit,\n  tsPropertyIndex,\n  tsRecord,\n  tsUnion,\n  tsWithRequired,\n} from \"../lib/ts.js\";\nimport { createDiscriminatorProperty, createRef, getEntries } from \"../lib/utils.js\";\nimport type { ReferenceObject, SchemaObject, TransformNodeOptions } from \"../types.js\";\n\n/**\n * Transform SchemaObject nodes (4.8.24)\n * @see https://spec.openapis.org/oas/v3.1.0#schema-object\n */\nexport default function transformSchemaObject(\n  schemaObject: SchemaObject | ReferenceObject,\n  options: TransformNodeOptions,\n): ts.TypeNode {\n  const type = transformSchemaObjectWithComposition(schemaObject, options);\n  if (typeof options.ctx.postTransform === \"function\") {\n    const postTransformResult = options.ctx.postTransform(type, options);\n    if (postTransformResult) {\n      return postTransformResult;\n    }\n  }\n  return type;\n}\n\n/**\n * Transform SchemaObjects\n */\nexport function transformSchemaObjectWithComposition(\n  schemaObject: SchemaObject | ReferenceObject,\n  options: TransformNodeOptions,\n): ts.TypeNode {\n  /**\n   * Unexpected types & edge cases\n   */\n\n  // missing/falsy type returns `never`\n  if (!schemaObject) {\n    return NEVER;\n  }\n  // `true` returns `unknown` (this exists, but is untyped)\n  if ((schemaObject as unknown) === true) {\n    return UNKNOWN;\n  }\n  // for any other unexpected type, throw error\n  if (Array.isArray(schemaObject) || typeof schemaObject !== \"object\") {\n    throw new Error(\n      `Expected SchemaObject, received ${Array.isArray(schemaObject) ? \"Array\" : typeof schemaObject} at ${options.path}`,\n    );\n  }\n\n  /**\n   * ReferenceObject\n   */\n  if (\"$ref\" in schemaObject) {\n    return oapiRef(schemaObject.$ref);\n  }\n\n  /**\n   * const (valid for any type)\n   */\n  if (schemaObject.const !== null && schemaObject.const !== undefined) {\n    return tsLiteral(schemaObject.const);\n  }\n\n  /**\n   * enum (non-objects)\n   * note: enum is valid for any type, but for objects, handle in oneOf below\n   */\n  if (\n    Array.isArray(schemaObject.enum) &&\n    (!(\"type\" in schemaObject) || schemaObject.type !== \"object\") &&\n    !(\"properties\" in schemaObject) &&\n    !(\"additionalProperties\" in schemaObject)\n  ) {\n    // hoist enum to top level if string/number enum and option is enabled\n    if (\n      options.ctx.enum &&\n      schemaObject.enum.every((v) => typeof v === \"string\" || typeof v === \"number\" || v === null)\n    ) {\n      let enumName = parseRef(options.path ?? \"\").pointer.join(\"/\");\n      // allow #/components/schemas to have simpler names\n      enumName = enumName.replace(\"components/schemas\", \"\");\n      const metadata = schemaObject.enum.map((_, i) => ({\n        name: schemaObject[\"x-enum-varnames\"]?.[i] ?? schemaObject[\"x-enumNames\"]?.[i],\n        description: schemaObject[\"x-enum-descriptions\"]?.[i] ?? schemaObject[\"x-enumDescriptions\"]?.[i],\n      }));\n\n      // enums can contain null values, but dont want to output them\n      let hasNull = false;\n      const validSchemaEnums = schemaObject.enum.filter((enumValue) => {\n        if (enumValue === null) {\n          hasNull = true;\n          return false;\n        }\n\n        return true;\n      });\n      const enumType = tsEnum(enumName, validSchemaEnums as (string | number)[], metadata, {\n        shouldCache: options.ctx.dedupeEnums,\n        export: true,\n        // readonly: TS enum do not support the readonly modifier\n      });\n      if (!options.ctx.injectFooter.includes(enumType)) {\n        options.ctx.injectFooter.push(enumType);\n      }\n      const ref = ts.factory.createTypeReferenceNode(enumType.name);\n      return hasNull ? tsUnion([ref, NULL]) : ref;\n    }\n    const enumType = schemaObject.enum.map(tsLiteral);\n    if ((Array.isArray(schemaObject.type) && schemaObject.type.includes(\"null\")) || schemaObject.nullable) {\n      enumType.push(NULL);\n    }\n\n    const unionType = tsUnion(enumType);\n\n    // hoist array with valid enum values to top level if string/number enum and option is enabled\n    if (options.ctx.enumValues && schemaObject.enum.every((v) => typeof v === \"string\" || typeof v === \"number\")) {\n      let enumValuesVariableName = parseRef(options.path ?? \"\").pointer.join(\"/\");\n      // allow #/components/schemas to have simpler names\n      enumValuesVariableName = enumValuesVariableName.replace(\"components/schemas\", \"\");\n      enumValuesVariableName = `${enumValuesVariableName}Values`;\n\n      const enumValuesArray = tsArrayLiteralExpression(\n        enumValuesVariableName,\n        oapiRef(options.path ?? \"\"),\n        schemaObject.enum as (string | number)[],\n        {\n          export: true,\n          readonly: true,\n          injectFooter: options.ctx.injectFooter,\n        },\n      );\n\n      options.ctx.injectFooter.push(enumValuesArray);\n    }\n\n    return unionType;\n  }\n\n  /**\n   * Object + composition (anyOf/allOf/oneOf) types\n   */\n\n  /** Collect oneOf/anyOf */\n  function collectUnionCompositions(items: (SchemaObject | ReferenceObject)[]) {\n    const output: ts.TypeNode[] = [];\n    for (const item of items) {\n      output.push(transformSchemaObject(item, options));\n    }\n\n    return output;\n  }\n\n  /** Collect allOf with Omit<> for discriminators */\n  function collectAllOfCompositions(items: (SchemaObject | ReferenceObject)[], required?: string[]): ts.TypeNode[] {\n    const output: ts.TypeNode[] = [];\n    for (const item of items) {\n      let itemType: ts.TypeNode;\n      // if this is a $ref, use WithRequired<X, Y> if parent specifies required properties\n      // (but only for valid keys)\n      if (\"$ref\" in item) {\n        itemType = transformSchemaObject(item, options);\n\n        const resolved = options.ctx.resolve<SchemaObject>(item.$ref);\n\n        // make keys required, if necessary\n        if (\n          resolved &&\n          typeof resolved === \"object\" &&\n          \"properties\" in resolved &&\n          // we have already handled this item (discriminator property was already added as required)\n          !options.ctx.discriminators.refsHandled.includes(item.$ref)\n        ) {\n          // add WithRequired<X, Y> if necessary\n          const validRequired = (required ?? []).filter((key) => !!resolved.properties?.[key]);\n          if (validRequired.length) {\n            itemType = tsWithRequired(itemType, validRequired, options.ctx.injectFooter);\n          }\n        }\n      }\n      // otherwise, if this is a schema object, combine parent `required[]` with its own, if any\n      else {\n        const itemRequired = [...(required ?? [])];\n        if (typeof item === \"object\" && Array.isArray(item.required)) {\n          itemRequired.push(...item.required);\n        }\n        itemType = transformSchemaObject({ ...item, required: itemRequired }, options);\n      }\n\n      const discriminator =\n        (\"$ref\" in item && options.ctx.discriminators.objects[item.$ref]) || (item as any).discriminator;\n      if (discriminator) {\n        output.push(tsOmit(itemType, [discriminator.propertyName]));\n      } else {\n        output.push(itemType);\n      }\n    }\n    return output;\n  }\n\n  // compile final type\n  let finalType: ts.TypeNode | undefined = undefined;\n\n  // core + allOf: intersect\n  const coreObjectType = transformSchemaObjectCore(schemaObject, options);\n  const allOfType = collectAllOfCompositions(schemaObject.allOf ?? [], schemaObject.required);\n  if (coreObjectType || allOfType.length) {\n    const allOf: ts.TypeNode | undefined = allOfType.length ? tsIntersection(allOfType) : undefined;\n    finalType = tsIntersection([...(coreObjectType ? [coreObjectType] : []), ...(allOf ? [allOf] : [])]);\n  }\n  // anyOf: union\n  // (note: this may seem counterintuitive, but as TypeScript’s unions are not true XORs, they mimic behavior closer to anyOf than oneOf)\n  const anyOfType = collectUnionCompositions(schemaObject.anyOf ?? []);\n  if (anyOfType.length) {\n    finalType = tsUnion([...(finalType ? [finalType] : []), ...anyOfType]);\n  }\n  // oneOf: union (within intersection with other types, if any)\n  const oneOfType = collectUnionCompositions(\n    schemaObject.oneOf ||\n      (\"type\" in schemaObject &&\n        schemaObject.type === \"object\" &&\n        (schemaObject.enum as (SchemaObject | ReferenceObject)[])) ||\n      [],\n  );\n  if (oneOfType.length) {\n    // note: oneOf is the only type that may include primitives\n    if (oneOfType.every(tsIsPrimitive)) {\n      finalType = tsUnion([...(finalType ? [finalType] : []), ...oneOfType]);\n    } else {\n      finalType = tsIntersection([...(finalType ? [finalType] : []), tsUnion(oneOfType)]);\n    }\n  }\n\n  // When no final type can be generated, fall back to unknown type (or related variants)\n  if (!finalType) {\n    if (\"type\" in schemaObject) {\n      finalType = tsRecord(STRING, options.ctx.emptyObjectsUnknown ? UNKNOWN : NEVER);\n    } else {\n      finalType = UNKNOWN;\n    }\n  }\n\n  if (finalType !== UNKNOWN && schemaObject.nullable) {\n    finalType = tsNullable([finalType]);\n  }\n\n  return finalType;\n}\n\n/**\n * Handle SchemaObject minus composition (anyOf/allOf/oneOf)\n */\nfunction transformSchemaObjectCore(schemaObject: SchemaObject, options: TransformNodeOptions): ts.TypeNode | undefined {\n  if (\"type\" in schemaObject && schemaObject.type) {\n    if (typeof options.ctx.transform === \"function\") {\n      const result = options.ctx.transform(schemaObject, options);\n      if (result && typeof result === \"object\") {\n        if (\"schema\" in result) {\n          if (result.questionToken) {\n            return ts.factory.createUnionTypeNode([result.schema, UNDEFINED]);\n          } else {\n            return result.schema;\n          }\n        } else {\n          return result;\n        }\n      }\n    }\n\n    // primitives\n    // type: null\n    if (schemaObject.type === \"null\") {\n      return NULL;\n    }\n    // type: string\n    if (schemaObject.type === \"string\") {\n      return STRING;\n    }\n    // type: number / type: integer\n    if (schemaObject.type === \"number\" || schemaObject.type === \"integer\") {\n      return NUMBER;\n    }\n    // type: boolean\n    if (schemaObject.type === \"boolean\") {\n      return BOOLEAN;\n    }\n\n    // type: array (with support for tuples)\n    if (schemaObject.type === \"array\") {\n      // default to `unknown[]`\n      let itemType: ts.TypeNode = UNKNOWN;\n      // tuple type\n      if (schemaObject.prefixItems || Array.isArray(schemaObject.items)) {\n        const prefixItems = schemaObject.prefixItems ?? (schemaObject.items as (SchemaObject | ReferenceObject)[]);\n        itemType = ts.factory.createTupleTypeNode(prefixItems.map((item) => transformSchemaObject(item, options)));\n      }\n      // standard array type\n      else if (schemaObject.items) {\n        if (hasKey(schemaObject.items, \"type\") && schemaObject.items.type === \"array\") {\n          itemType = ts.factory.createArrayTypeNode(transformSchemaObject(schemaObject.items, options));\n        } else {\n          itemType = transformSchemaObject(schemaObject.items, options);\n        }\n      }\n\n      const min: number =\n        typeof schemaObject.minItems === \"number\" && schemaObject.minItems >= 0 ? schemaObject.minItems : 0;\n      const max: number | undefined =\n        typeof schemaObject.maxItems === \"number\" && schemaObject.maxItems >= 0 && min <= schemaObject.maxItems\n          ? schemaObject.maxItems\n          : undefined;\n      const estimateCodeSize = typeof max !== \"number\" ? min : (max * (max + 1) - min * (min - 1)) / 2;\n      if (\n        options.ctx.arrayLength &&\n        (min !== 0 || max !== undefined) &&\n        estimateCodeSize < 30 // \"30\" is an arbitrary number but roughly around when TS starts to struggle with tuple inference in practice\n      ) {\n        if (min === max) {\n          const elements: ts.TypeNode[] = [];\n          for (let i = 0; i < min; i++) {\n            elements.push(itemType);\n          }\n          return tsUnion([ts.factory.createTupleTypeNode(elements)]);\n        } else if ((schemaObject.maxItems as number) > 0) {\n          // if maxItems is set, then return a union of all permutations of possible tuple types\n          const members: ts.TypeNode[] = [];\n          // populate 1 short of min …\n          for (let i = 0; i <= (max ?? 0) - min; i++) {\n            const elements: ts.TypeNode[] = [];\n            for (let j = min; j < i + min; j++) {\n              elements.push(itemType);\n            }\n            members.push(ts.factory.createTupleTypeNode(elements));\n          }\n          return tsUnion(members);\n        }\n        // if maxItems not set, then return a simple tuple type the length of `min`\n        else {\n          const elements: ts.TypeNode[] = [];\n          for (let i = 0; i < min; i++) {\n            elements.push(itemType);\n          }\n          elements.push(ts.factory.createRestTypeNode(ts.factory.createArrayTypeNode(itemType)));\n          return ts.factory.createTupleTypeNode(elements);\n        }\n      }\n\n      const finalType =\n        ts.isTupleTypeNode(itemType) || ts.isArrayTypeNode(itemType)\n          ? itemType\n          : ts.factory.createArrayTypeNode(itemType); // wrap itemType in array type, but only if not a tuple or array already\n\n      return options.ctx.immutable\n        ? ts.factory.createTypeOperatorNode(ts.SyntaxKind.ReadonlyKeyword, finalType)\n        : finalType;\n    }\n\n    // polymorphic, or 3.1 nullable\n    if (Array.isArray(schemaObject.type) && !Array.isArray(schemaObject)) {\n      // skip any primitive types that appear in oneOf as well\n      const uniqueTypes: ts.TypeNode[] = [];\n      if (Array.isArray(schemaObject.oneOf)) {\n        for (const t of schemaObject.type) {\n          if (\n            (t === \"boolean\" || t === \"string\" || t === \"number\" || t === \"integer\" || t === \"null\") &&\n            schemaObject.oneOf.find((o) => typeof o === \"object\" && \"type\" in o && o.type === t)\n          ) {\n            continue;\n          }\n          uniqueTypes.push(\n            t === \"null\" || t === null\n              ? NULL\n              : transformSchemaObject(\n                  { ...schemaObject, type: t, oneOf: undefined } as SchemaObject, // don’t stack oneOf transforms\n                  options,\n                ),\n          );\n        }\n      } else {\n        for (const t of schemaObject.type) {\n          if (t === \"null\" || t === null) {\n            uniqueTypes.push(NULL);\n          } else {\n            uniqueTypes.push(transformSchemaObject({ ...schemaObject, type: t } as SchemaObject, options));\n          }\n        }\n      }\n      return tsUnion(uniqueTypes);\n    }\n  }\n\n  // type: object\n  const coreObjectType: ts.TypeElement[] = [];\n\n  // discriminators: explicit mapping on schema object\n  for (const k of [\"allOf\", \"anyOf\"] as const) {\n    if (!schemaObject[k]) {\n      continue;\n    }\n    // for all magic inheritance, we will have already gathered it into\n    // ctx.discriminators. But stop objects from referencing their own\n    // discriminator meant for children (!schemaObject.discriminator)\n    // and don't add discriminator properties if we already added/patched\n    // them (options.ctx.discriminators.refsHandled.includes(options.path!).\n    const discriminator =\n      !schemaObject.discriminator &&\n      !options.ctx.discriminators.refsHandled.includes(options.path ?? \"\") &&\n      options.ctx.discriminators.objects[options.path ?? \"\"];\n    if (discriminator) {\n      coreObjectType.unshift(\n        createDiscriminatorProperty(discriminator, {\n          path: options.path ?? \"\",\n          readonly: options.ctx.immutable,\n        }),\n      );\n      break;\n    }\n  }\n\n  if (\n    (\"properties\" in schemaObject && schemaObject.properties && Object.keys(schemaObject.properties).length) ||\n    (\"additionalProperties\" in schemaObject && schemaObject.additionalProperties) ||\n    (\"$defs\" in schemaObject && schemaObject.$defs)\n  ) {\n    // properties\n    if (Object.keys(schemaObject.properties ?? {}).length) {\n      for (const [k, v] of getEntries(schemaObject.properties ?? {}, options.ctx)) {\n        if ((typeof v !== \"object\" && typeof v !== \"boolean\") || Array.isArray(v)) {\n          throw new Error(\n            `${options.path}: invalid property ${k}. Expected Schema Object or boolean, got ${\n              Array.isArray(v) ? \"Array\" : typeof v\n            }`,\n          );\n        }\n\n        const { $ref, readOnly, hasDefault } =\n          typeof v === \"object\"\n            ? {\n                $ref: \"$ref\" in v && v.$ref,\n                readOnly: \"readOnly\" in v && v.readOnly,\n                hasDefault: \"default\" in v && v.default !== undefined,\n              }\n            : {};\n\n        // handle excludeDeprecated option\n        if (options.ctx.excludeDeprecated) {\n          const resolved = $ref ? options.ctx.resolve<SchemaObject>($ref) : v;\n          if ((resolved as SchemaObject)?.deprecated) {\n            continue;\n          }\n        }\n        let optional =\n          schemaObject.required?.includes(k) ||\n          (schemaObject.required === undefined && options.ctx.propertiesRequiredByDefault) ||\n          (hasDefault &&\n            options.ctx.defaultNonNullable &&\n            !options.path?.includes(\"parameters\") &&\n            !options.path?.includes(\"requestBody\") &&\n            !options.path?.includes(\"requestBodies\")) // can’t be required, even with defaults\n            ? undefined\n            : QUESTION_TOKEN;\n        let type = $ref\n          ? oapiRef($ref)\n          : transformSchemaObject(v, {\n              ...options,\n              path: createRef([options.path, k]),\n            });\n\n        if (typeof options.ctx.transform === \"function\") {\n          const result = options.ctx.transform(v as SchemaObject, options);\n          if (result && typeof result === \"object\") {\n            if (\"schema\" in result) {\n              type = result.schema;\n              optional = result.questionToken ? QUESTION_TOKEN : optional;\n            } else {\n              type = result;\n            }\n          }\n        }\n\n        const property = ts.factory.createPropertySignature(\n          /* modifiers     */ tsModifiers({\n            readonly: options.ctx.immutable || readOnly,\n          }),\n          /* name          */ tsPropertyIndex(k),\n          /* questionToken */ optional,\n          /* type          */ type,\n        );\n        addJSDocComment(v, property);\n        coreObjectType.push(property);\n      }\n    }\n\n    // $defs\n    if (schemaObject.$defs && typeof schemaObject.$defs === \"object\" && Object.keys(schemaObject.$defs).length) {\n      const defKeys: ts.TypeElement[] = [];\n      for (const [k, v] of Object.entries(schemaObject.$defs)) {\n        const property = ts.factory.createPropertySignature(\n          /* modifiers    */ tsModifiers({\n            readonly: options.ctx.immutable || (\"readonly\" in v && !!v.readOnly),\n          }),\n          /* name          */ tsPropertyIndex(k),\n          /* questionToken */ undefined,\n          /* type          */ transformSchemaObject(v, {\n            ...options,\n            path: createRef([options.path, \"$defs\", k]),\n          }),\n        );\n        addJSDocComment(v, property);\n        defKeys.push(property);\n      }\n      coreObjectType.push(\n        ts.factory.createPropertySignature(\n          /* modifiers     */ undefined,\n          /* name          */ tsPropertyIndex(\"$defs\"),\n          /* questionToken */ undefined,\n          /* type          */ ts.factory.createTypeLiteralNode(defKeys),\n        ),\n      );\n    }\n\n    // additionalProperties\n    if (schemaObject.additionalProperties || options.ctx.additionalProperties) {\n      const hasExplicitAdditionalProperties =\n        typeof schemaObject.additionalProperties === \"object\" && Object.keys(schemaObject.additionalProperties).length;\n      const addlType = hasExplicitAdditionalProperties\n        ? transformSchemaObject(schemaObject.additionalProperties as SchemaObject, options)\n        : UNKNOWN;\n      return tsIntersection([\n        ...(coreObjectType.length ? [ts.factory.createTypeLiteralNode(coreObjectType)] : []),\n        ts.factory.createTypeLiteralNode([\n          ts.factory.createIndexSignature(\n            /* modifiers  */ tsModifiers({\n              readonly: options.ctx.immutable,\n            }),\n            /* parameters */ [\n              ts.factory.createParameterDeclaration(\n                /* modifiers      */ undefined,\n                /* dotDotDotToken */ undefined,\n                /* name           */ ts.factory.createIdentifier(\"key\"),\n                /* questionToken  */ undefined,\n                /* type           */ STRING,\n              ),\n            ],\n            /* type       */ addlType,\n          ),\n        ]),\n      ]);\n    }\n  }\n\n  return coreObjectType.length ? ts.factory.createTypeLiteralNode(coreObjectType) : undefined;\n}\n\n/**\n * Check if an object has a key\n * @param possibleObject - The object to check\n * @param key - The key to check for\n * @returns True if the object has the key, false otherwise\n */\nfunction hasKey<K extends string>(possibleObject: unknown, key: K): possibleObject is { [key in K]: unknown } {\n  return typeof possibleObject === \"object\" && possibleObject !== null && key in possibleObject;\n}\n"],"names":["NEVER","UNKNOWN","oapiRef","tsLiteral","parseRef","enumType","tsEnum","ts","tsUnion","NULL","tsArrayLiteralExpression","tsWithRequired","tsOmit","tsIntersection","tsIsPrimitive","tsRecord","STRING","tsNullable","UNDEFINED","NUMBER","BOOLEAN","createDiscriminatorProperty","getEntries","QUESTION_TOKEN","createRef","tsModifiers","tsPropertyIndex","addJSDocComment"],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"schema-object.cjs","sources":["../../src/transform/schema-object.ts"],"sourcesContent":["import { parseRef } from \"@redocly/openapi-core/lib/ref-utils.js\";\nimport ts from \"typescript\";\nimport {\n  BOOLEAN,\n  NEVER,\n  NULL,\n  NUMBER,\n  QUESTION_TOKEN,\n  STRING,\n  UNDEFINED,\n  UNKNOWN,\n  addJSDocComment,\n  oapiRef,\n  tsArrayLiteralExpression,\n  tsEnum,\n  tsIntersection,\n  tsIsPrimitive,\n  tsLiteral,\n  tsModifiers,\n  tsNullable,\n  tsOmit,\n  tsPropertyIndex,\n  tsRecord,\n  tsUnion,\n  tsWithRequired,\n} from \"../lib/ts.js\";\nimport { createDiscriminatorProperty, createRef, getEntries } from \"../lib/utils.js\";\nimport type { ReferenceObject, SchemaObject, TransformNodeOptions } from \"../types.js\";\n\n/**\n * Transform SchemaObject nodes (4.8.24)\n * @see https://spec.openapis.org/oas/v3.1.0#schema-object\n */\nexport default function transformSchemaObject(\n  schemaObject: SchemaObject | ReferenceObject,\n  options: TransformNodeOptions,\n): ts.TypeNode {\n  const type = transformSchemaObjectWithComposition(schemaObject, options);\n  if (typeof options.ctx.postTransform === \"function\") {\n    const postTransformResult = options.ctx.postTransform(type, options);\n    if (postTransformResult) {\n      return postTransformResult;\n    }\n  }\n  return type;\n}\n\n/**\n * Transform SchemaObjects\n */\nexport function transformSchemaObjectWithComposition(\n  schemaObject: SchemaObject | ReferenceObject,\n  options: TransformNodeOptions,\n): ts.TypeNode {\n  /**\n   * Unexpected types & edge cases\n   */\n\n  // missing/falsy type returns `never`\n  if (!schemaObject) {\n    return NEVER;\n  }\n  // `true` returns `unknown` (this exists, but is untyped)\n  if ((schemaObject as unknown) === true) {\n    return UNKNOWN;\n  }\n  // for any other unexpected type, throw error\n  if (Array.isArray(schemaObject) || typeof schemaObject !== \"object\") {\n    throw new Error(\n      `Expected SchemaObject, received ${Array.isArray(schemaObject) ? \"Array\" : typeof schemaObject} at ${options.path}`,\n    );\n  }\n\n  /**\n   * ReferenceObject\n   */\n  if (\"$ref\" in schemaObject) {\n    return oapiRef(schemaObject.$ref);\n  }\n\n  /**\n   * const (valid for any type)\n   */\n  if (schemaObject.const !== null && schemaObject.const !== undefined) {\n    return tsLiteral(schemaObject.const);\n  }\n\n  /**\n   * enum (non-objects)\n   * note: enum is valid for any type, but for objects, handle in oneOf below\n   */\n  if (\n    Array.isArray(schemaObject.enum) &&\n    (!(\"type\" in schemaObject) || schemaObject.type !== \"object\") &&\n    !(\"properties\" in schemaObject) &&\n    !(\"additionalProperties\" in schemaObject)\n  ) {\n    // hoist enum to top level if string/number enum and option is enabled\n    if (\n      options.ctx.enum &&\n      schemaObject.enum.every((v) => typeof v === \"string\" || typeof v === \"number\" || v === null)\n    ) {\n      const enumName = (() => {\n        // specific to codebloom, is a requirement in regards to [509](https://codebloom.notion.site/Fix-enum-2c37c85563aa807e91ddd0ddf7937cc7)\n        if (schemaObject.description) {\n          return schemaObject.description;\n        }\n\n        let n = parseRef(options.path ?? \"\").pointer.join(\"/\");\n        // allow #/components/schemas to have simpler names\n        n = n.replace(\"components/schemas\", \"\");\n        return n;\n      })();\n      const metadata = schemaObject.enum.map((_, i) => ({\n        name: schemaObject[\"x-enum-varnames\"]?.[i] ?? schemaObject[\"x-enumNames\"]?.[i],\n        description: schemaObject[\"x-enum-descriptions\"]?.[i] ?? schemaObject[\"x-enumDescriptions\"]?.[i],\n      }));\n\n      // enums can contain null values, but dont want to output them\n      let hasNull = false;\n      const validSchemaEnums = schemaObject.enum.filter((enumValue) => {\n        if (enumValue === null) {\n          hasNull = true;\n          return false;\n        }\n\n        return true;\n      });\n      const enumType = tsEnum(enumName, validSchemaEnums as (string | number)[], metadata, {\n        shouldCache: options.ctx.dedupeEnums,\n        export: true,\n        // readonly: TS enum do not support the readonly modifier\n      });\n      if (!options.ctx.injectFooter.includes(enumType)) {\n        options.ctx.injectFooter.push(enumType);\n      }\n      const ref = ts.factory.createTypeReferenceNode(enumType.name);\n      return hasNull ? tsUnion([ref, NULL]) : ref;\n    }\n    const enumType = schemaObject.enum.map(tsLiteral);\n    if ((Array.isArray(schemaObject.type) && schemaObject.type.includes(\"null\")) || schemaObject.nullable) {\n      enumType.push(NULL);\n    }\n\n    const unionType = tsUnion(enumType);\n\n    // hoist array with valid enum values to top level if string/number enum and option is enabled\n    if (options.ctx.enumValues && schemaObject.enum.every((v) => typeof v === \"string\" || typeof v === \"number\")) {\n      let enumValuesVariableName = parseRef(options.path ?? \"\").pointer.join(\"/\");\n      // allow #/components/schemas to have simpler names\n      enumValuesVariableName = enumValuesVariableName.replace(\"components/schemas\", \"\");\n      enumValuesVariableName = `${enumValuesVariableName}Values`;\n\n      const enumValuesArray = tsArrayLiteralExpression(\n        enumValuesVariableName,\n        oapiRef(options.path ?? \"\"),\n        schemaObject.enum as (string | number)[],\n        {\n          export: true,\n          readonly: true,\n          injectFooter: options.ctx.injectFooter,\n        },\n      );\n\n      options.ctx.injectFooter.push(enumValuesArray);\n    }\n\n    return unionType;\n  }\n\n  /**\n   * Object + composition (anyOf/allOf/oneOf) types\n   */\n\n  /** Collect oneOf/anyOf */\n  function collectUnionCompositions(items: (SchemaObject | ReferenceObject)[]) {\n    const output: ts.TypeNode[] = [];\n    for (const item of items) {\n      output.push(transformSchemaObject(item, options));\n    }\n\n    return output;\n  }\n\n  /** Collect allOf with Omit<> for discriminators */\n  function collectAllOfCompositions(items: (SchemaObject | ReferenceObject)[], required?: string[]): ts.TypeNode[] {\n    const output: ts.TypeNode[] = [];\n    for (const item of items) {\n      let itemType: ts.TypeNode;\n      // if this is a $ref, use WithRequired<X, Y> if parent specifies required properties\n      // (but only for valid keys)\n      if (\"$ref\" in item) {\n        itemType = transformSchemaObject(item, options);\n\n        const resolved = options.ctx.resolve<SchemaObject>(item.$ref);\n\n        // make keys required, if necessary\n        if (\n          resolved &&\n          typeof resolved === \"object\" &&\n          \"properties\" in resolved &&\n          // we have already handled this item (discriminator property was already added as required)\n          !options.ctx.discriminators.refsHandled.includes(item.$ref)\n        ) {\n          // add WithRequired<X, Y> if necessary\n          const validRequired = (required ?? []).filter((key) => !!resolved.properties?.[key]);\n          if (validRequired.length) {\n            itemType = tsWithRequired(itemType, validRequired, options.ctx.injectFooter);\n          }\n        }\n      }\n      // otherwise, if this is a schema object, combine parent `required[]` with its own, if any\n      else {\n        const itemRequired = [...(required ?? [])];\n        if (typeof item === \"object\" && Array.isArray(item.required)) {\n          itemRequired.push(...item.required);\n        }\n        itemType = transformSchemaObject({ ...item, required: itemRequired }, options);\n      }\n\n      const discriminator =\n        (\"$ref\" in item && options.ctx.discriminators.objects[item.$ref]) || (item as any).discriminator;\n      if (discriminator) {\n        output.push(tsOmit(itemType, [discriminator.propertyName]));\n      } else {\n        output.push(itemType);\n      }\n    }\n    return output;\n  }\n\n  // compile final type\n  let finalType: ts.TypeNode | undefined = undefined;\n\n  // core + allOf: intersect\n  const coreObjectType = transformSchemaObjectCore(schemaObject, options);\n  const allOfType = collectAllOfCompositions(schemaObject.allOf ?? [], schemaObject.required);\n  if (coreObjectType || allOfType.length) {\n    const allOf: ts.TypeNode | undefined = allOfType.length ? tsIntersection(allOfType) : undefined;\n    finalType = tsIntersection([...(coreObjectType ? [coreObjectType] : []), ...(allOf ? [allOf] : [])]);\n  }\n  // anyOf: union\n  // (note: this may seem counterintuitive, but as TypeScript’s unions are not true XORs, they mimic behavior closer to anyOf than oneOf)\n  const anyOfType = collectUnionCompositions(schemaObject.anyOf ?? []);\n  if (anyOfType.length) {\n    finalType = tsUnion([...(finalType ? [finalType] : []), ...anyOfType]);\n  }\n  // oneOf: union (within intersection with other types, if any)\n  const oneOfType = collectUnionCompositions(\n    schemaObject.oneOf ||\n      (\"type\" in schemaObject &&\n        schemaObject.type === \"object\" &&\n        (schemaObject.enum as (SchemaObject | ReferenceObject)[])) ||\n      [],\n  );\n  if (oneOfType.length) {\n    // note: oneOf is the only type that may include primitives\n    if (oneOfType.every(tsIsPrimitive)) {\n      finalType = tsUnion([...(finalType ? [finalType] : []), ...oneOfType]);\n    } else {\n      finalType = tsIntersection([...(finalType ? [finalType] : []), tsUnion(oneOfType)]);\n    }\n  }\n\n  // When no final type can be generated, fall back to unknown type (or related variants)\n  if (!finalType) {\n    if (\"type\" in schemaObject) {\n      finalType = tsRecord(STRING, options.ctx.emptyObjectsUnknown ? UNKNOWN : NEVER);\n    } else {\n      finalType = UNKNOWN;\n    }\n  }\n\n  if (finalType !== UNKNOWN && schemaObject.nullable) {\n    finalType = tsNullable([finalType]);\n  }\n\n  return finalType;\n}\n\n/**\n * Handle SchemaObject minus composition (anyOf/allOf/oneOf)\n */\nfunction transformSchemaObjectCore(schemaObject: SchemaObject, options: TransformNodeOptions): ts.TypeNode | undefined {\n  if (\"type\" in schemaObject && schemaObject.type) {\n    if (typeof options.ctx.transform === \"function\") {\n      const result = options.ctx.transform(schemaObject, options);\n      if (result && typeof result === \"object\") {\n        if (\"schema\" in result) {\n          if (result.questionToken) {\n            return ts.factory.createUnionTypeNode([result.schema, UNDEFINED]);\n          } else {\n            return result.schema;\n          }\n        } else {\n          return result;\n        }\n      }\n    }\n\n    // primitives\n    // type: null\n    if (schemaObject.type === \"null\") {\n      return NULL;\n    }\n    // type: string\n    if (schemaObject.type === \"string\") {\n      return STRING;\n    }\n    // type: number / type: integer\n    if (schemaObject.type === \"number\" || schemaObject.type === \"integer\") {\n      return NUMBER;\n    }\n    // type: boolean\n    if (schemaObject.type === \"boolean\") {\n      return BOOLEAN;\n    }\n\n    // type: array (with support for tuples)\n    if (schemaObject.type === \"array\") {\n      // default to `unknown[]`\n      let itemType: ts.TypeNode = UNKNOWN;\n      // tuple type\n      if (schemaObject.prefixItems || Array.isArray(schemaObject.items)) {\n        const prefixItems = schemaObject.prefixItems ?? (schemaObject.items as (SchemaObject | ReferenceObject)[]);\n        itemType = ts.factory.createTupleTypeNode(prefixItems.map((item) => transformSchemaObject(item, options)));\n      }\n      // standard array type\n      else if (schemaObject.items) {\n        if (hasKey(schemaObject.items, \"type\") && schemaObject.items.type === \"array\") {\n          itemType = ts.factory.createArrayTypeNode(transformSchemaObject(schemaObject.items, options));\n        } else {\n          itemType = transformSchemaObject(schemaObject.items, options);\n        }\n      }\n\n      const min: number =\n        typeof schemaObject.minItems === \"number\" && schemaObject.minItems >= 0 ? schemaObject.minItems : 0;\n      const max: number | undefined =\n        typeof schemaObject.maxItems === \"number\" && schemaObject.maxItems >= 0 && min <= schemaObject.maxItems\n          ? schemaObject.maxItems\n          : undefined;\n      const estimateCodeSize = typeof max !== \"number\" ? min : (max * (max + 1) - min * (min - 1)) / 2;\n      if (\n        options.ctx.arrayLength &&\n        (min !== 0 || max !== undefined) &&\n        estimateCodeSize < 30 // \"30\" is an arbitrary number but roughly around when TS starts to struggle with tuple inference in practice\n      ) {\n        if (min === max) {\n          const elements: ts.TypeNode[] = [];\n          for (let i = 0; i < min; i++) {\n            elements.push(itemType);\n          }\n          return tsUnion([ts.factory.createTupleTypeNode(elements)]);\n        } else if ((schemaObject.maxItems as number) > 0) {\n          // if maxItems is set, then return a union of all permutations of possible tuple types\n          const members: ts.TypeNode[] = [];\n          // populate 1 short of min …\n          for (let i = 0; i <= (max ?? 0) - min; i++) {\n            const elements: ts.TypeNode[] = [];\n            for (let j = min; j < i + min; j++) {\n              elements.push(itemType);\n            }\n            members.push(ts.factory.createTupleTypeNode(elements));\n          }\n          return tsUnion(members);\n        }\n        // if maxItems not set, then return a simple tuple type the length of `min`\n        else {\n          const elements: ts.TypeNode[] = [];\n          for (let i = 0; i < min; i++) {\n            elements.push(itemType);\n          }\n          elements.push(ts.factory.createRestTypeNode(ts.factory.createArrayTypeNode(itemType)));\n          return ts.factory.createTupleTypeNode(elements);\n        }\n      }\n\n      const finalType =\n        ts.isTupleTypeNode(itemType) || ts.isArrayTypeNode(itemType)\n          ? itemType\n          : ts.factory.createArrayTypeNode(itemType); // wrap itemType in array type, but only if not a tuple or array already\n\n      return options.ctx.immutable\n        ? ts.factory.createTypeOperatorNode(ts.SyntaxKind.ReadonlyKeyword, finalType)\n        : finalType;\n    }\n\n    // polymorphic, or 3.1 nullable\n    if (Array.isArray(schemaObject.type) && !Array.isArray(schemaObject)) {\n      // skip any primitive types that appear in oneOf as well\n      const uniqueTypes: ts.TypeNode[] = [];\n      if (Array.isArray(schemaObject.oneOf)) {\n        for (const t of schemaObject.type) {\n          if (\n            (t === \"boolean\" || t === \"string\" || t === \"number\" || t === \"integer\" || t === \"null\") &&\n            schemaObject.oneOf.find((o) => typeof o === \"object\" && \"type\" in o && o.type === t)\n          ) {\n            continue;\n          }\n          uniqueTypes.push(\n            t === \"null\" || t === null\n              ? NULL\n              : transformSchemaObject(\n                  { ...schemaObject, type: t, oneOf: undefined } as SchemaObject, // don’t stack oneOf transforms\n                  options,\n                ),\n          );\n        }\n      } else {\n        for (const t of schemaObject.type) {\n          if (t === \"null\" || t === null) {\n            uniqueTypes.push(NULL);\n          } else {\n            uniqueTypes.push(transformSchemaObject({ ...schemaObject, type: t } as SchemaObject, options));\n          }\n        }\n      }\n      return tsUnion(uniqueTypes);\n    }\n  }\n\n  // type: object\n  const coreObjectType: ts.TypeElement[] = [];\n\n  // discriminators: explicit mapping on schema object\n  for (const k of [\"allOf\", \"anyOf\"] as const) {\n    if (!schemaObject[k]) {\n      continue;\n    }\n    // for all magic inheritance, we will have already gathered it into\n    // ctx.discriminators. But stop objects from referencing their own\n    // discriminator meant for children (!schemaObject.discriminator)\n    // and don't add discriminator properties if we already added/patched\n    // them (options.ctx.discriminators.refsHandled.includes(options.path!).\n    const discriminator =\n      !schemaObject.discriminator &&\n      !options.ctx.discriminators.refsHandled.includes(options.path ?? \"\") &&\n      options.ctx.discriminators.objects[options.path ?? \"\"];\n    if (discriminator) {\n      coreObjectType.unshift(\n        createDiscriminatorProperty(discriminator, {\n          path: options.path ?? \"\",\n          readonly: options.ctx.immutable,\n        }),\n      );\n      break;\n    }\n  }\n\n  if (\n    (\"properties\" in schemaObject && schemaObject.properties && Object.keys(schemaObject.properties).length) ||\n    (\"additionalProperties\" in schemaObject && schemaObject.additionalProperties) ||\n    (\"$defs\" in schemaObject && schemaObject.$defs)\n  ) {\n    // properties\n    if (Object.keys(schemaObject.properties ?? {}).length) {\n      for (const [k, v] of getEntries(schemaObject.properties ?? {}, options.ctx)) {\n        if ((typeof v !== \"object\" && typeof v !== \"boolean\") || Array.isArray(v)) {\n          throw new Error(\n            `${options.path}: invalid property ${k}. Expected Schema Object or boolean, got ${\n              Array.isArray(v) ? \"Array\" : typeof v\n            }`,\n          );\n        }\n\n        const { $ref, readOnly, hasDefault } =\n          typeof v === \"object\"\n            ? {\n                $ref: \"$ref\" in v && v.$ref,\n                readOnly: \"readOnly\" in v && v.readOnly,\n                hasDefault: \"default\" in v && v.default !== undefined,\n              }\n            : {};\n\n        // handle excludeDeprecated option\n        if (options.ctx.excludeDeprecated) {\n          const resolved = $ref ? options.ctx.resolve<SchemaObject>($ref) : v;\n          if ((resolved as SchemaObject)?.deprecated) {\n            continue;\n          }\n        }\n        let optional =\n          schemaObject.required?.includes(k) ||\n          (schemaObject.required === undefined && options.ctx.propertiesRequiredByDefault) ||\n          (hasDefault &&\n            options.ctx.defaultNonNullable &&\n            !options.path?.includes(\"parameters\") &&\n            !options.path?.includes(\"requestBody\") &&\n            !options.path?.includes(\"requestBodies\")) // can’t be required, even with defaults\n            ? undefined\n            : QUESTION_TOKEN;\n        let type = $ref\n          ? oapiRef($ref)\n          : transformSchemaObject(v, {\n              ...options,\n              path: createRef([options.path, k]),\n            });\n\n        if (typeof options.ctx.transform === \"function\") {\n          const result = options.ctx.transform(v as SchemaObject, options);\n          if (result && typeof result === \"object\") {\n            if (\"schema\" in result) {\n              type = result.schema;\n              optional = result.questionToken ? QUESTION_TOKEN : optional;\n            } else {\n              type = result;\n            }\n          }\n        }\n\n        const property = ts.factory.createPropertySignature(\n          /* modifiers     */ tsModifiers({\n            readonly: options.ctx.immutable || readOnly,\n          }),\n          /* name          */ tsPropertyIndex(k),\n          /* questionToken */ optional,\n          /* type          */ type,\n        );\n        addJSDocComment(v, property);\n        coreObjectType.push(property);\n      }\n    }\n\n    // $defs\n    if (schemaObject.$defs && typeof schemaObject.$defs === \"object\" && Object.keys(schemaObject.$defs).length) {\n      const defKeys: ts.TypeElement[] = [];\n      for (const [k, v] of Object.entries(schemaObject.$defs)) {\n        const property = ts.factory.createPropertySignature(\n          /* modifiers    */ tsModifiers({\n            readonly: options.ctx.immutable || (\"readonly\" in v && !!v.readOnly),\n          }),\n          /* name          */ tsPropertyIndex(k),\n          /* questionToken */ undefined,\n          /* type          */ transformSchemaObject(v, {\n            ...options,\n            path: createRef([options.path, \"$defs\", k]),\n          }),\n        );\n        addJSDocComment(v, property);\n        defKeys.push(property);\n      }\n      coreObjectType.push(\n        ts.factory.createPropertySignature(\n          /* modifiers     */ undefined,\n          /* name          */ tsPropertyIndex(\"$defs\"),\n          /* questionToken */ undefined,\n          /* type          */ ts.factory.createTypeLiteralNode(defKeys),\n        ),\n      );\n    }\n\n    // additionalProperties\n    if (schemaObject.additionalProperties || options.ctx.additionalProperties) {\n      const hasExplicitAdditionalProperties =\n        typeof schemaObject.additionalProperties === \"object\" && Object.keys(schemaObject.additionalProperties).length;\n      const addlType = hasExplicitAdditionalProperties\n        ? transformSchemaObject(schemaObject.additionalProperties as SchemaObject, options)\n        : UNKNOWN;\n      return tsIntersection([\n        ...(coreObjectType.length ? [ts.factory.createTypeLiteralNode(coreObjectType)] : []),\n        ts.factory.createTypeLiteralNode([\n          ts.factory.createIndexSignature(\n            /* modifiers  */ tsModifiers({\n              readonly: options.ctx.immutable,\n            }),\n            /* parameters */ [\n              ts.factory.createParameterDeclaration(\n                /* modifiers      */ undefined,\n                /* dotDotDotToken */ undefined,\n                /* name           */ ts.factory.createIdentifier(\"key\"),\n                /* questionToken  */ undefined,\n                /* type           */ STRING,\n              ),\n            ],\n            /* type       */ addlType,\n          ),\n        ]),\n      ]);\n    }\n  }\n\n  return coreObjectType.length ? ts.factory.createTypeLiteralNode(coreObjectType) : undefined;\n}\n\n/**\n * Check if an object has a key\n * @param possibleObject - The object to check\n * @param key - The key to check for\n * @returns True if the object has the key, false otherwise\n */\nfunction hasKey<K extends string>(possibleObject: unknown, key: K): possibleObject is { [key in K]: unknown } {\n  return typeof possibleObject === \"object\" && possibleObject !== null && key in possibleObject;\n}\n"],"names":["NEVER","UNKNOWN","oapiRef","tsLiteral","parseRef","enumType","tsEnum","ts","tsUnion","NULL","tsArrayLiteralExpression","tsWithRequired","tsOmit","tsIntersection","tsIsPrimitive","tsRecord","STRING","tsNullable","UNDEFINED","NUMBER","BOOLEAN","createDiscriminatorProperty","getEntries","QUESTION_TOKEN","createRef","tsModifiers","tsPropertyIndex","addJSDocComment"],"mappings":"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"}
diff --git a/dist/transform/schema-object.mjs b/dist/transform/schema-object.mjs
index bfcae19270bf33024cc76dbc78aa24617ef7876e..73a1ccf9809cde05497bf9901fd5ca2d6a7ac9ea 100644
--- a/dist/transform/schema-object.mjs
+++ b/dist/transform/schema-object.mjs
@@ -33,8 +33,14 @@ function transformSchemaObjectWithComposition(schemaObject, options) {
   }
   if (Array.isArray(schemaObject.enum) && (!("type" in schemaObject) || schemaObject.type !== "object") && !("properties" in schemaObject) && !("additionalProperties" in schemaObject)) {
     if (options.ctx.enum && schemaObject.enum.every((v) => typeof v === "string" || typeof v === "number" || v === null)) {
-      let enumName = parseRef(options.path ?? "").pointer.join("/");
-      enumName = enumName.replace("components/schemas", "");
+      const enumName = (() => {
+        if (schemaObject.description) {
+          return schemaObject.description;
+        }
+        let n = parseRef(options.path ?? "").pointer.join("/");
+        n = n.replace("components/schemas", "");
+        return n;
+      })();
       const metadata = schemaObject.enum.map((_, i) => ({
         name: schemaObject["x-enum-varnames"]?.[i] ?? schemaObject["x-enumNames"]?.[i],
         description: schemaObject["x-enum-descriptions"]?.[i] ?? schemaObject["x-enumDescriptions"]?.[i]
diff --git a/dist/transform/schema-object.mjs.map b/dist/transform/schema-object.mjs.map
index 7b2c8d6ba4ebcb92e26820db1b7acf7db78e840b..229353ebfde7c6f93d677825b8552a1ca07cdb56 100644
--- a/dist/transform/schema-object.mjs.map
+++ b/dist/transform/schema-object.mjs.map
@@ -1 +1 @@
-{"version":3,"file":"schema-object.mjs","sources":["../../src/transform/schema-object.ts"],"sourcesContent":["import { parseRef } from \"@redocly/openapi-core/lib/ref-utils.js\";\nimport ts from \"typescript\";\nimport {\n  BOOLEAN,\n  NEVER,\n  NULL,\n  NUMBER,\n  QUESTION_TOKEN,\n  STRING,\n  UNDEFINED,\n  UNKNOWN,\n  addJSDocComment,\n  oapiRef,\n  tsArrayLiteralExpression,\n  tsEnum,\n  tsIntersection,\n  tsIsPrimitive,\n  tsLiteral,\n  tsModifiers,\n  tsNullable,\n  tsOmit,\n  tsPropertyIndex,\n  tsRecord,\n  tsUnion,\n  tsWithRequired,\n} from \"../lib/ts.js\";\nimport { createDiscriminatorProperty, createRef, getEntries } from \"../lib/utils.js\";\nimport type { ReferenceObject, SchemaObject, TransformNodeOptions } from \"../types.js\";\n\n/**\n * Transform SchemaObject nodes (4.8.24)\n * @see https://spec.openapis.org/oas/v3.1.0#schema-object\n */\nexport default function transformSchemaObject(\n  schemaObject: SchemaObject | ReferenceObject,\n  options: TransformNodeOptions,\n): ts.TypeNode {\n  const type = transformSchemaObjectWithComposition(schemaObject, options);\n  if (typeof options.ctx.postTransform === \"function\") {\n    const postTransformResult = options.ctx.postTransform(type, options);\n    if (postTransformResult) {\n      return postTransformResult;\n    }\n  }\n  return type;\n}\n\n/**\n * Transform SchemaObjects\n */\nexport function transformSchemaObjectWithComposition(\n  schemaObject: SchemaObject | ReferenceObject,\n  options: TransformNodeOptions,\n): ts.TypeNode {\n  /**\n   * Unexpected types & edge cases\n   */\n\n  // missing/falsy type returns `never`\n  if (!schemaObject) {\n    return NEVER;\n  }\n  // `true` returns `unknown` (this exists, but is untyped)\n  if ((schemaObject as unknown) === true) {\n    return UNKNOWN;\n  }\n  // for any other unexpected type, throw error\n  if (Array.isArray(schemaObject) || typeof schemaObject !== \"object\") {\n    throw new Error(\n      `Expected SchemaObject, received ${Array.isArray(schemaObject) ? \"Array\" : typeof schemaObject} at ${options.path}`,\n    );\n  }\n\n  /**\n   * ReferenceObject\n   */\n  if (\"$ref\" in schemaObject) {\n    return oapiRef(schemaObject.$ref);\n  }\n\n  /**\n   * const (valid for any type)\n   */\n  if (schemaObject.const !== null && schemaObject.const !== undefined) {\n    return tsLiteral(schemaObject.const);\n  }\n\n  /**\n   * enum (non-objects)\n   * note: enum is valid for any type, but for objects, handle in oneOf below\n   */\n  if (\n    Array.isArray(schemaObject.enum) &&\n    (!(\"type\" in schemaObject) || schemaObject.type !== \"object\") &&\n    !(\"properties\" in schemaObject) &&\n    !(\"additionalProperties\" in schemaObject)\n  ) {\n    // hoist enum to top level if string/number enum and option is enabled\n    if (\n      options.ctx.enum &&\n      schemaObject.enum.every((v) => typeof v === \"string\" || typeof v === \"number\" || v === null)\n    ) {\n      let enumName = parseRef(options.path ?? \"\").pointer.join(\"/\");\n      // allow #/components/schemas to have simpler names\n      enumName = enumName.replace(\"components/schemas\", \"\");\n      const metadata = schemaObject.enum.map((_, i) => ({\n        name: schemaObject[\"x-enum-varnames\"]?.[i] ?? schemaObject[\"x-enumNames\"]?.[i],\n        description: schemaObject[\"x-enum-descriptions\"]?.[i] ?? schemaObject[\"x-enumDescriptions\"]?.[i],\n      }));\n\n      // enums can contain null values, but dont want to output them\n      let hasNull = false;\n      const validSchemaEnums = schemaObject.enum.filter((enumValue) => {\n        if (enumValue === null) {\n          hasNull = true;\n          return false;\n        }\n\n        return true;\n      });\n      const enumType = tsEnum(enumName, validSchemaEnums as (string | number)[], metadata, {\n        shouldCache: options.ctx.dedupeEnums,\n        export: true,\n        // readonly: TS enum do not support the readonly modifier\n      });\n      if (!options.ctx.injectFooter.includes(enumType)) {\n        options.ctx.injectFooter.push(enumType);\n      }\n      const ref = ts.factory.createTypeReferenceNode(enumType.name);\n      return hasNull ? tsUnion([ref, NULL]) : ref;\n    }\n    const enumType = schemaObject.enum.map(tsLiteral);\n    if ((Array.isArray(schemaObject.type) && schemaObject.type.includes(\"null\")) || schemaObject.nullable) {\n      enumType.push(NULL);\n    }\n\n    const unionType = tsUnion(enumType);\n\n    // hoist array with valid enum values to top level if string/number enum and option is enabled\n    if (options.ctx.enumValues && schemaObject.enum.every((v) => typeof v === \"string\" || typeof v === \"number\")) {\n      let enumValuesVariableName = parseRef(options.path ?? \"\").pointer.join(\"/\");\n      // allow #/components/schemas to have simpler names\n      enumValuesVariableName = enumValuesVariableName.replace(\"components/schemas\", \"\");\n      enumValuesVariableName = `${enumValuesVariableName}Values`;\n\n      const enumValuesArray = tsArrayLiteralExpression(\n        enumValuesVariableName,\n        oapiRef(options.path ?? \"\"),\n        schemaObject.enum as (string | number)[],\n        {\n          export: true,\n          readonly: true,\n          injectFooter: options.ctx.injectFooter,\n        },\n      );\n\n      options.ctx.injectFooter.push(enumValuesArray);\n    }\n\n    return unionType;\n  }\n\n  /**\n   * Object + composition (anyOf/allOf/oneOf) types\n   */\n\n  /** Collect oneOf/anyOf */\n  function collectUnionCompositions(items: (SchemaObject | ReferenceObject)[]) {\n    const output: ts.TypeNode[] = [];\n    for (const item of items) {\n      output.push(transformSchemaObject(item, options));\n    }\n\n    return output;\n  }\n\n  /** Collect allOf with Omit<> for discriminators */\n  function collectAllOfCompositions(items: (SchemaObject | ReferenceObject)[], required?: string[]): ts.TypeNode[] {\n    const output: ts.TypeNode[] = [];\n    for (const item of items) {\n      let itemType: ts.TypeNode;\n      // if this is a $ref, use WithRequired<X, Y> if parent specifies required properties\n      // (but only for valid keys)\n      if (\"$ref\" in item) {\n        itemType = transformSchemaObject(item, options);\n\n        const resolved = options.ctx.resolve<SchemaObject>(item.$ref);\n\n        // make keys required, if necessary\n        if (\n          resolved &&\n          typeof resolved === \"object\" &&\n          \"properties\" in resolved &&\n          // we have already handled this item (discriminator property was already added as required)\n          !options.ctx.discriminators.refsHandled.includes(item.$ref)\n        ) {\n          // add WithRequired<X, Y> if necessary\n          const validRequired = (required ?? []).filter((key) => !!resolved.properties?.[key]);\n          if (validRequired.length) {\n            itemType = tsWithRequired(itemType, validRequired, options.ctx.injectFooter);\n          }\n        }\n      }\n      // otherwise, if this is a schema object, combine parent `required[]` with its own, if any\n      else {\n        const itemRequired = [...(required ?? [])];\n        if (typeof item === \"object\" && Array.isArray(item.required)) {\n          itemRequired.push(...item.required);\n        }\n        itemType = transformSchemaObject({ ...item, required: itemRequired }, options);\n      }\n\n      const discriminator =\n        (\"$ref\" in item && options.ctx.discriminators.objects[item.$ref]) || (item as any).discriminator;\n      if (discriminator) {\n        output.push(tsOmit(itemType, [discriminator.propertyName]));\n      } else {\n        output.push(itemType);\n      }\n    }\n    return output;\n  }\n\n  // compile final type\n  let finalType: ts.TypeNode | undefined = undefined;\n\n  // core + allOf: intersect\n  const coreObjectType = transformSchemaObjectCore(schemaObject, options);\n  const allOfType = collectAllOfCompositions(schemaObject.allOf ?? [], schemaObject.required);\n  if (coreObjectType || allOfType.length) {\n    const allOf: ts.TypeNode | undefined = allOfType.length ? tsIntersection(allOfType) : undefined;\n    finalType = tsIntersection([...(coreObjectType ? [coreObjectType] : []), ...(allOf ? [allOf] : [])]);\n  }\n  // anyOf: union\n  // (note: this may seem counterintuitive, but as TypeScript’s unions are not true XORs, they mimic behavior closer to anyOf than oneOf)\n  const anyOfType = collectUnionCompositions(schemaObject.anyOf ?? []);\n  if (anyOfType.length) {\n    finalType = tsUnion([...(finalType ? [finalType] : []), ...anyOfType]);\n  }\n  // oneOf: union (within intersection with other types, if any)\n  const oneOfType = collectUnionCompositions(\n    schemaObject.oneOf ||\n      (\"type\" in schemaObject &&\n        schemaObject.type === \"object\" &&\n        (schemaObject.enum as (SchemaObject | ReferenceObject)[])) ||\n      [],\n  );\n  if (oneOfType.length) {\n    // note: oneOf is the only type that may include primitives\n    if (oneOfType.every(tsIsPrimitive)) {\n      finalType = tsUnion([...(finalType ? [finalType] : []), ...oneOfType]);\n    } else {\n      finalType = tsIntersection([...(finalType ? [finalType] : []), tsUnion(oneOfType)]);\n    }\n  }\n\n  // When no final type can be generated, fall back to unknown type (or related variants)\n  if (!finalType) {\n    if (\"type\" in schemaObject) {\n      finalType = tsRecord(STRING, options.ctx.emptyObjectsUnknown ? UNKNOWN : NEVER);\n    } else {\n      finalType = UNKNOWN;\n    }\n  }\n\n  if (finalType !== UNKNOWN && schemaObject.nullable) {\n    finalType = tsNullable([finalType]);\n  }\n\n  return finalType;\n}\n\n/**\n * Handle SchemaObject minus composition (anyOf/allOf/oneOf)\n */\nfunction transformSchemaObjectCore(schemaObject: SchemaObject, options: TransformNodeOptions): ts.TypeNode | undefined {\n  if (\"type\" in schemaObject && schemaObject.type) {\n    if (typeof options.ctx.transform === \"function\") {\n      const result = options.ctx.transform(schemaObject, options);\n      if (result && typeof result === \"object\") {\n        if (\"schema\" in result) {\n          if (result.questionToken) {\n            return ts.factory.createUnionTypeNode([result.schema, UNDEFINED]);\n          } else {\n            return result.schema;\n          }\n        } else {\n          return result;\n        }\n      }\n    }\n\n    // primitives\n    // type: null\n    if (schemaObject.type === \"null\") {\n      return NULL;\n    }\n    // type: string\n    if (schemaObject.type === \"string\") {\n      return STRING;\n    }\n    // type: number / type: integer\n    if (schemaObject.type === \"number\" || schemaObject.type === \"integer\") {\n      return NUMBER;\n    }\n    // type: boolean\n    if (schemaObject.type === \"boolean\") {\n      return BOOLEAN;\n    }\n\n    // type: array (with support for tuples)\n    if (schemaObject.type === \"array\") {\n      // default to `unknown[]`\n      let itemType: ts.TypeNode = UNKNOWN;\n      // tuple type\n      if (schemaObject.prefixItems || Array.isArray(schemaObject.items)) {\n        const prefixItems = schemaObject.prefixItems ?? (schemaObject.items as (SchemaObject | ReferenceObject)[]);\n        itemType = ts.factory.createTupleTypeNode(prefixItems.map((item) => transformSchemaObject(item, options)));\n      }\n      // standard array type\n      else if (schemaObject.items) {\n        if (hasKey(schemaObject.items, \"type\") && schemaObject.items.type === \"array\") {\n          itemType = ts.factory.createArrayTypeNode(transformSchemaObject(schemaObject.items, options));\n        } else {\n          itemType = transformSchemaObject(schemaObject.items, options);\n        }\n      }\n\n      const min: number =\n        typeof schemaObject.minItems === \"number\" && schemaObject.minItems >= 0 ? schemaObject.minItems : 0;\n      const max: number | undefined =\n        typeof schemaObject.maxItems === \"number\" && schemaObject.maxItems >= 0 && min <= schemaObject.maxItems\n          ? schemaObject.maxItems\n          : undefined;\n      const estimateCodeSize = typeof max !== \"number\" ? min : (max * (max + 1) - min * (min - 1)) / 2;\n      if (\n        options.ctx.arrayLength &&\n        (min !== 0 || max !== undefined) &&\n        estimateCodeSize < 30 // \"30\" is an arbitrary number but roughly around when TS starts to struggle with tuple inference in practice\n      ) {\n        if (min === max) {\n          const elements: ts.TypeNode[] = [];\n          for (let i = 0; i < min; i++) {\n            elements.push(itemType);\n          }\n          return tsUnion([ts.factory.createTupleTypeNode(elements)]);\n        } else if ((schemaObject.maxItems as number) > 0) {\n          // if maxItems is set, then return a union of all permutations of possible tuple types\n          const members: ts.TypeNode[] = [];\n          // populate 1 short of min …\n          for (let i = 0; i <= (max ?? 0) - min; i++) {\n            const elements: ts.TypeNode[] = [];\n            for (let j = min; j < i + min; j++) {\n              elements.push(itemType);\n            }\n            members.push(ts.factory.createTupleTypeNode(elements));\n          }\n          return tsUnion(members);\n        }\n        // if maxItems not set, then return a simple tuple type the length of `min`\n        else {\n          const elements: ts.TypeNode[] = [];\n          for (let i = 0; i < min; i++) {\n            elements.push(itemType);\n          }\n          elements.push(ts.factory.createRestTypeNode(ts.factory.createArrayTypeNode(itemType)));\n          return ts.factory.createTupleTypeNode(elements);\n        }\n      }\n\n      const finalType =\n        ts.isTupleTypeNode(itemType) || ts.isArrayTypeNode(itemType)\n          ? itemType\n          : ts.factory.createArrayTypeNode(itemType); // wrap itemType in array type, but only if not a tuple or array already\n\n      return options.ctx.immutable\n        ? ts.factory.createTypeOperatorNode(ts.SyntaxKind.ReadonlyKeyword, finalType)\n        : finalType;\n    }\n\n    // polymorphic, or 3.1 nullable\n    if (Array.isArray(schemaObject.type) && !Array.isArray(schemaObject)) {\n      // skip any primitive types that appear in oneOf as well\n      const uniqueTypes: ts.TypeNode[] = [];\n      if (Array.isArray(schemaObject.oneOf)) {\n        for (const t of schemaObject.type) {\n          if (\n            (t === \"boolean\" || t === \"string\" || t === \"number\" || t === \"integer\" || t === \"null\") &&\n            schemaObject.oneOf.find((o) => typeof o === \"object\" && \"type\" in o && o.type === t)\n          ) {\n            continue;\n          }\n          uniqueTypes.push(\n            t === \"null\" || t === null\n              ? NULL\n              : transformSchemaObject(\n                  { ...schemaObject, type: t, oneOf: undefined } as SchemaObject, // don’t stack oneOf transforms\n                  options,\n                ),\n          );\n        }\n      } else {\n        for (const t of schemaObject.type) {\n          if (t === \"null\" || t === null) {\n            uniqueTypes.push(NULL);\n          } else {\n            uniqueTypes.push(transformSchemaObject({ ...schemaObject, type: t } as SchemaObject, options));\n          }\n        }\n      }\n      return tsUnion(uniqueTypes);\n    }\n  }\n\n  // type: object\n  const coreObjectType: ts.TypeElement[] = [];\n\n  // discriminators: explicit mapping on schema object\n  for (const k of [\"allOf\", \"anyOf\"] as const) {\n    if (!schemaObject[k]) {\n      continue;\n    }\n    // for all magic inheritance, we will have already gathered it into\n    // ctx.discriminators. But stop objects from referencing their own\n    // discriminator meant for children (!schemaObject.discriminator)\n    // and don't add discriminator properties if we already added/patched\n    // them (options.ctx.discriminators.refsHandled.includes(options.path!).\n    const discriminator =\n      !schemaObject.discriminator &&\n      !options.ctx.discriminators.refsHandled.includes(options.path ?? \"\") &&\n      options.ctx.discriminators.objects[options.path ?? \"\"];\n    if (discriminator) {\n      coreObjectType.unshift(\n        createDiscriminatorProperty(discriminator, {\n          path: options.path ?? \"\",\n          readonly: options.ctx.immutable,\n        }),\n      );\n      break;\n    }\n  }\n\n  if (\n    (\"properties\" in schemaObject && schemaObject.properties && Object.keys(schemaObject.properties).length) ||\n    (\"additionalProperties\" in schemaObject && schemaObject.additionalProperties) ||\n    (\"$defs\" in schemaObject && schemaObject.$defs)\n  ) {\n    // properties\n    if (Object.keys(schemaObject.properties ?? {}).length) {\n      for (const [k, v] of getEntries(schemaObject.properties ?? {}, options.ctx)) {\n        if ((typeof v !== \"object\" && typeof v !== \"boolean\") || Array.isArray(v)) {\n          throw new Error(\n            `${options.path}: invalid property ${k}. Expected Schema Object or boolean, got ${\n              Array.isArray(v) ? \"Array\" : typeof v\n            }`,\n          );\n        }\n\n        const { $ref, readOnly, hasDefault } =\n          typeof v === \"object\"\n            ? {\n                $ref: \"$ref\" in v && v.$ref,\n                readOnly: \"readOnly\" in v && v.readOnly,\n                hasDefault: \"default\" in v && v.default !== undefined,\n              }\n            : {};\n\n        // handle excludeDeprecated option\n        if (options.ctx.excludeDeprecated) {\n          const resolved = $ref ? options.ctx.resolve<SchemaObject>($ref) : v;\n          if ((resolved as SchemaObject)?.deprecated) {\n            continue;\n          }\n        }\n        let optional =\n          schemaObject.required?.includes(k) ||\n          (schemaObject.required === undefined && options.ctx.propertiesRequiredByDefault) ||\n          (hasDefault &&\n            options.ctx.defaultNonNullable &&\n            !options.path?.includes(\"parameters\") &&\n            !options.path?.includes(\"requestBody\") &&\n            !options.path?.includes(\"requestBodies\")) // can’t be required, even with defaults\n            ? undefined\n            : QUESTION_TOKEN;\n        let type = $ref\n          ? oapiRef($ref)\n          : transformSchemaObject(v, {\n              ...options,\n              path: createRef([options.path, k]),\n            });\n\n        if (typeof options.ctx.transform === \"function\") {\n          const result = options.ctx.transform(v as SchemaObject, options);\n          if (result && typeof result === \"object\") {\n            if (\"schema\" in result) {\n              type = result.schema;\n              optional = result.questionToken ? QUESTION_TOKEN : optional;\n            } else {\n              type = result;\n            }\n          }\n        }\n\n        const property = ts.factory.createPropertySignature(\n          /* modifiers     */ tsModifiers({\n            readonly: options.ctx.immutable || readOnly,\n          }),\n          /* name          */ tsPropertyIndex(k),\n          /* questionToken */ optional,\n          /* type          */ type,\n        );\n        addJSDocComment(v, property);\n        coreObjectType.push(property);\n      }\n    }\n\n    // $defs\n    if (schemaObject.$defs && typeof schemaObject.$defs === \"object\" && Object.keys(schemaObject.$defs).length) {\n      const defKeys: ts.TypeElement[] = [];\n      for (const [k, v] of Object.entries(schemaObject.$defs)) {\n        const property = ts.factory.createPropertySignature(\n          /* modifiers    */ tsModifiers({\n            readonly: options.ctx.immutable || (\"readonly\" in v && !!v.readOnly),\n          }),\n          /* name          */ tsPropertyIndex(k),\n          /* questionToken */ undefined,\n          /* type          */ transformSchemaObject(v, {\n            ...options,\n            path: createRef([options.path, \"$defs\", k]),\n          }),\n        );\n        addJSDocComment(v, property);\n        defKeys.push(property);\n      }\n      coreObjectType.push(\n        ts.factory.createPropertySignature(\n          /* modifiers     */ undefined,\n          /* name          */ tsPropertyIndex(\"$defs\"),\n          /* questionToken */ undefined,\n          /* type          */ ts.factory.createTypeLiteralNode(defKeys),\n        ),\n      );\n    }\n\n    // additionalProperties\n    if (schemaObject.additionalProperties || options.ctx.additionalProperties) {\n      const hasExplicitAdditionalProperties =\n        typeof schemaObject.additionalProperties === \"object\" && Object.keys(schemaObject.additionalProperties).length;\n      const addlType = hasExplicitAdditionalProperties\n        ? transformSchemaObject(schemaObject.additionalProperties as SchemaObject, options)\n        : UNKNOWN;\n      return tsIntersection([\n        ...(coreObjectType.length ? [ts.factory.createTypeLiteralNode(coreObjectType)] : []),\n        ts.factory.createTypeLiteralNode([\n          ts.factory.createIndexSignature(\n            /* modifiers  */ tsModifiers({\n              readonly: options.ctx.immutable,\n            }),\n            /* parameters */ [\n              ts.factory.createParameterDeclaration(\n                /* modifiers      */ undefined,\n                /* dotDotDotToken */ undefined,\n                /* name           */ ts.factory.createIdentifier(\"key\"),\n                /* questionToken  */ undefined,\n                /* type           */ STRING,\n              ),\n            ],\n            /* type       */ addlType,\n          ),\n        ]),\n      ]);\n    }\n  }\n\n  return coreObjectType.length ? ts.factory.createTypeLiteralNode(coreObjectType) : undefined;\n}\n\n/**\n * Check if an object has a key\n * @param possibleObject - The object to check\n * @param key - The key to check for\n * @returns True if the object has the key, false otherwise\n */\nfunction hasKey<K extends string>(possibleObject: unknown, key: K): possibleObject is { [key in K]: unknown } {\n  return typeof possibleObject === \"object\" && possibleObject !== null && key in possibleObject;\n}\n"],"names":["enumType"],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"schema-object.mjs","sources":["../../src/transform/schema-object.ts"],"sourcesContent":["import { parseRef } from \"@redocly/openapi-core/lib/ref-utils.js\";\nimport ts from \"typescript\";\nimport {\n  BOOLEAN,\n  NEVER,\n  NULL,\n  NUMBER,\n  QUESTION_TOKEN,\n  STRING,\n  UNDEFINED,\n  UNKNOWN,\n  addJSDocComment,\n  oapiRef,\n  tsArrayLiteralExpression,\n  tsEnum,\n  tsIntersection,\n  tsIsPrimitive,\n  tsLiteral,\n  tsModifiers,\n  tsNullable,\n  tsOmit,\n  tsPropertyIndex,\n  tsRecord,\n  tsUnion,\n  tsWithRequired,\n} from \"../lib/ts.js\";\nimport { createDiscriminatorProperty, createRef, getEntries } from \"../lib/utils.js\";\nimport type { ReferenceObject, SchemaObject, TransformNodeOptions } from \"../types.js\";\n\n/**\n * Transform SchemaObject nodes (4.8.24)\n * @see https://spec.openapis.org/oas/v3.1.0#schema-object\n */\nexport default function transformSchemaObject(\n  schemaObject: SchemaObject | ReferenceObject,\n  options: TransformNodeOptions,\n): ts.TypeNode {\n  const type = transformSchemaObjectWithComposition(schemaObject, options);\n  if (typeof options.ctx.postTransform === \"function\") {\n    const postTransformResult = options.ctx.postTransform(type, options);\n    if (postTransformResult) {\n      return postTransformResult;\n    }\n  }\n  return type;\n}\n\n/**\n * Transform SchemaObjects\n */\nexport function transformSchemaObjectWithComposition(\n  schemaObject: SchemaObject | ReferenceObject,\n  options: TransformNodeOptions,\n): ts.TypeNode {\n  /**\n   * Unexpected types & edge cases\n   */\n\n  // missing/falsy type returns `never`\n  if (!schemaObject) {\n    return NEVER;\n  }\n  // `true` returns `unknown` (this exists, but is untyped)\n  if ((schemaObject as unknown) === true) {\n    return UNKNOWN;\n  }\n  // for any other unexpected type, throw error\n  if (Array.isArray(schemaObject) || typeof schemaObject !== \"object\") {\n    throw new Error(\n      `Expected SchemaObject, received ${Array.isArray(schemaObject) ? \"Array\" : typeof schemaObject} at ${options.path}`,\n    );\n  }\n\n  /**\n   * ReferenceObject\n   */\n  if (\"$ref\" in schemaObject) {\n    return oapiRef(schemaObject.$ref);\n  }\n\n  /**\n   * const (valid for any type)\n   */\n  if (schemaObject.const !== null && schemaObject.const !== undefined) {\n    return tsLiteral(schemaObject.const);\n  }\n\n  /**\n   * enum (non-objects)\n   * note: enum is valid for any type, but for objects, handle in oneOf below\n   */\n  if (\n    Array.isArray(schemaObject.enum) &&\n    (!(\"type\" in schemaObject) || schemaObject.type !== \"object\") &&\n    !(\"properties\" in schemaObject) &&\n    !(\"additionalProperties\" in schemaObject)\n  ) {\n    // hoist enum to top level if string/number enum and option is enabled\n    if (\n      options.ctx.enum &&\n      schemaObject.enum.every((v) => typeof v === \"string\" || typeof v === \"number\" || v === null)\n    ) {\n      const enumName = (() => {\n        // specific to codebloom, is a requirement in regards to [509](https://codebloom.notion.site/Fix-enum-2c37c85563aa807e91ddd0ddf7937cc7)\n        if (schemaObject.description) {\n          return schemaObject.description;\n        }\n\n        let n = parseRef(options.path ?? \"\").pointer.join(\"/\");\n        // allow #/components/schemas to have simpler names\n        n = n.replace(\"components/schemas\", \"\");\n        return n;\n      })();\n      const metadata = schemaObject.enum.map((_, i) => ({\n        name: schemaObject[\"x-enum-varnames\"]?.[i] ?? schemaObject[\"x-enumNames\"]?.[i],\n        description: schemaObject[\"x-enum-descriptions\"]?.[i] ?? schemaObject[\"x-enumDescriptions\"]?.[i],\n      }));\n\n      // enums can contain null values, but dont want to output them\n      let hasNull = false;\n      const validSchemaEnums = schemaObject.enum.filter((enumValue) => {\n        if (enumValue === null) {\n          hasNull = true;\n          return false;\n        }\n\n        return true;\n      });\n      const enumType = tsEnum(enumName, validSchemaEnums as (string | number)[], metadata, {\n        shouldCache: options.ctx.dedupeEnums,\n        export: true,\n        // readonly: TS enum do not support the readonly modifier\n      });\n      if (!options.ctx.injectFooter.includes(enumType)) {\n        options.ctx.injectFooter.push(enumType);\n      }\n      const ref = ts.factory.createTypeReferenceNode(enumType.name);\n      return hasNull ? tsUnion([ref, NULL]) : ref;\n    }\n    const enumType = schemaObject.enum.map(tsLiteral);\n    if ((Array.isArray(schemaObject.type) && schemaObject.type.includes(\"null\")) || schemaObject.nullable) {\n      enumType.push(NULL);\n    }\n\n    const unionType = tsUnion(enumType);\n\n    // hoist array with valid enum values to top level if string/number enum and option is enabled\n    if (options.ctx.enumValues && schemaObject.enum.every((v) => typeof v === \"string\" || typeof v === \"number\")) {\n      let enumValuesVariableName = parseRef(options.path ?? \"\").pointer.join(\"/\");\n      // allow #/components/schemas to have simpler names\n      enumValuesVariableName = enumValuesVariableName.replace(\"components/schemas\", \"\");\n      enumValuesVariableName = `${enumValuesVariableName}Values`;\n\n      const enumValuesArray = tsArrayLiteralExpression(\n        enumValuesVariableName,\n        oapiRef(options.path ?? \"\"),\n        schemaObject.enum as (string | number)[],\n        {\n          export: true,\n          readonly: true,\n          injectFooter: options.ctx.injectFooter,\n        },\n      );\n\n      options.ctx.injectFooter.push(enumValuesArray);\n    }\n\n    return unionType;\n  }\n\n  /**\n   * Object + composition (anyOf/allOf/oneOf) types\n   */\n\n  /** Collect oneOf/anyOf */\n  function collectUnionCompositions(items: (SchemaObject | ReferenceObject)[]) {\n    const output: ts.TypeNode[] = [];\n    for (const item of items) {\n      output.push(transformSchemaObject(item, options));\n    }\n\n    return output;\n  }\n\n  /** Collect allOf with Omit<> for discriminators */\n  function collectAllOfCompositions(items: (SchemaObject | ReferenceObject)[], required?: string[]): ts.TypeNode[] {\n    const output: ts.TypeNode[] = [];\n    for (const item of items) {\n      let itemType: ts.TypeNode;\n      // if this is a $ref, use WithRequired<X, Y> if parent specifies required properties\n      // (but only for valid keys)\n      if (\"$ref\" in item) {\n        itemType = transformSchemaObject(item, options);\n\n        const resolved = options.ctx.resolve<SchemaObject>(item.$ref);\n\n        // make keys required, if necessary\n        if (\n          resolved &&\n          typeof resolved === \"object\" &&\n          \"properties\" in resolved &&\n          // we have already handled this item (discriminator property was already added as required)\n          !options.ctx.discriminators.refsHandled.includes(item.$ref)\n        ) {\n          // add WithRequired<X, Y> if necessary\n          const validRequired = (required ?? []).filter((key) => !!resolved.properties?.[key]);\n          if (validRequired.length) {\n            itemType = tsWithRequired(itemType, validRequired, options.ctx.injectFooter);\n          }\n        }\n      }\n      // otherwise, if this is a schema object, combine parent `required[]` with its own, if any\n      else {\n        const itemRequired = [...(required ?? [])];\n        if (typeof item === \"object\" && Array.isArray(item.required)) {\n          itemRequired.push(...item.required);\n        }\n        itemType = transformSchemaObject({ ...item, required: itemRequired }, options);\n      }\n\n      const discriminator =\n        (\"$ref\" in item && options.ctx.discriminators.objects[item.$ref]) || (item as any).discriminator;\n      if (discriminator) {\n        output.push(tsOmit(itemType, [discriminator.propertyName]));\n      } else {\n        output.push(itemType);\n      }\n    }\n    return output;\n  }\n\n  // compile final type\n  let finalType: ts.TypeNode | undefined = undefined;\n\n  // core + allOf: intersect\n  const coreObjectType = transformSchemaObjectCore(schemaObject, options);\n  const allOfType = collectAllOfCompositions(schemaObject.allOf ?? [], schemaObject.required);\n  if (coreObjectType || allOfType.length) {\n    const allOf: ts.TypeNode | undefined = allOfType.length ? tsIntersection(allOfType) : undefined;\n    finalType = tsIntersection([...(coreObjectType ? [coreObjectType] : []), ...(allOf ? [allOf] : [])]);\n  }\n  // anyOf: union\n  // (note: this may seem counterintuitive, but as TypeScript’s unions are not true XORs, they mimic behavior closer to anyOf than oneOf)\n  const anyOfType = collectUnionCompositions(schemaObject.anyOf ?? []);\n  if (anyOfType.length) {\n    finalType = tsUnion([...(finalType ? [finalType] : []), ...anyOfType]);\n  }\n  // oneOf: union (within intersection with other types, if any)\n  const oneOfType = collectUnionCompositions(\n    schemaObject.oneOf ||\n      (\"type\" in schemaObject &&\n        schemaObject.type === \"object\" &&\n        (schemaObject.enum as (SchemaObject | ReferenceObject)[])) ||\n      [],\n  );\n  if (oneOfType.length) {\n    // note: oneOf is the only type that may include primitives\n    if (oneOfType.every(tsIsPrimitive)) {\n      finalType = tsUnion([...(finalType ? [finalType] : []), ...oneOfType]);\n    } else {\n      finalType = tsIntersection([...(finalType ? [finalType] : []), tsUnion(oneOfType)]);\n    }\n  }\n\n  // When no final type can be generated, fall back to unknown type (or related variants)\n  if (!finalType) {\n    if (\"type\" in schemaObject) {\n      finalType = tsRecord(STRING, options.ctx.emptyObjectsUnknown ? UNKNOWN : NEVER);\n    } else {\n      finalType = UNKNOWN;\n    }\n  }\n\n  if (finalType !== UNKNOWN && schemaObject.nullable) {\n    finalType = tsNullable([finalType]);\n  }\n\n  return finalType;\n}\n\n/**\n * Handle SchemaObject minus composition (anyOf/allOf/oneOf)\n */\nfunction transformSchemaObjectCore(schemaObject: SchemaObject, options: TransformNodeOptions): ts.TypeNode | undefined {\n  if (\"type\" in schemaObject && schemaObject.type) {\n    if (typeof options.ctx.transform === \"function\") {\n      const result = options.ctx.transform(schemaObject, options);\n      if (result && typeof result === \"object\") {\n        if (\"schema\" in result) {\n          if (result.questionToken) {\n            return ts.factory.createUnionTypeNode([result.schema, UNDEFINED]);\n          } else {\n            return result.schema;\n          }\n        } else {\n          return result;\n        }\n      }\n    }\n\n    // primitives\n    // type: null\n    if (schemaObject.type === \"null\") {\n      return NULL;\n    }\n    // type: string\n    if (schemaObject.type === \"string\") {\n      return STRING;\n    }\n    // type: number / type: integer\n    if (schemaObject.type === \"number\" || schemaObject.type === \"integer\") {\n      return NUMBER;\n    }\n    // type: boolean\n    if (schemaObject.type === \"boolean\") {\n      return BOOLEAN;\n    }\n\n    // type: array (with support for tuples)\n    if (schemaObject.type === \"array\") {\n      // default to `unknown[]`\n      let itemType: ts.TypeNode = UNKNOWN;\n      // tuple type\n      if (schemaObject.prefixItems || Array.isArray(schemaObject.items)) {\n        const prefixItems = schemaObject.prefixItems ?? (schemaObject.items as (SchemaObject | ReferenceObject)[]);\n        itemType = ts.factory.createTupleTypeNode(prefixItems.map((item) => transformSchemaObject(item, options)));\n      }\n      // standard array type\n      else if (schemaObject.items) {\n        if (hasKey(schemaObject.items, \"type\") && schemaObject.items.type === \"array\") {\n          itemType = ts.factory.createArrayTypeNode(transformSchemaObject(schemaObject.items, options));\n        } else {\n          itemType = transformSchemaObject(schemaObject.items, options);\n        }\n      }\n\n      const min: number =\n        typeof schemaObject.minItems === \"number\" && schemaObject.minItems >= 0 ? schemaObject.minItems : 0;\n      const max: number | undefined =\n        typeof schemaObject.maxItems === \"number\" && schemaObject.maxItems >= 0 && min <= schemaObject.maxItems\n          ? schemaObject.maxItems\n          : undefined;\n      const estimateCodeSize = typeof max !== \"number\" ? min : (max * (max + 1) - min * (min - 1)) / 2;\n      if (\n        options.ctx.arrayLength &&\n        (min !== 0 || max !== undefined) &&\n        estimateCodeSize < 30 // \"30\" is an arbitrary number but roughly around when TS starts to struggle with tuple inference in practice\n      ) {\n        if (min === max) {\n          const elements: ts.TypeNode[] = [];\n          for (let i = 0; i < min; i++) {\n            elements.push(itemType);\n          }\n          return tsUnion([ts.factory.createTupleTypeNode(elements)]);\n        } else if ((schemaObject.maxItems as number) > 0) {\n          // if maxItems is set, then return a union of all permutations of possible tuple types\n          const members: ts.TypeNode[] = [];\n          // populate 1 short of min …\n          for (let i = 0; i <= (max ?? 0) - min; i++) {\n            const elements: ts.TypeNode[] = [];\n            for (let j = min; j < i + min; j++) {\n              elements.push(itemType);\n            }\n            members.push(ts.factory.createTupleTypeNode(elements));\n          }\n          return tsUnion(members);\n        }\n        // if maxItems not set, then return a simple tuple type the length of `min`\n        else {\n          const elements: ts.TypeNode[] = [];\n          for (let i = 0; i < min; i++) {\n            elements.push(itemType);\n          }\n          elements.push(ts.factory.createRestTypeNode(ts.factory.createArrayTypeNode(itemType)));\n          return ts.factory.createTupleTypeNode(elements);\n        }\n      }\n\n      const finalType =\n        ts.isTupleTypeNode(itemType) || ts.isArrayTypeNode(itemType)\n          ? itemType\n          : ts.factory.createArrayTypeNode(itemType); // wrap itemType in array type, but only if not a tuple or array already\n\n      return options.ctx.immutable\n        ? ts.factory.createTypeOperatorNode(ts.SyntaxKind.ReadonlyKeyword, finalType)\n        : finalType;\n    }\n\n    // polymorphic, or 3.1 nullable\n    if (Array.isArray(schemaObject.type) && !Array.isArray(schemaObject)) {\n      // skip any primitive types that appear in oneOf as well\n      const uniqueTypes: ts.TypeNode[] = [];\n      if (Array.isArray(schemaObject.oneOf)) {\n        for (const t of schemaObject.type) {\n          if (\n            (t === \"boolean\" || t === \"string\" || t === \"number\" || t === \"integer\" || t === \"null\") &&\n            schemaObject.oneOf.find((o) => typeof o === \"object\" && \"type\" in o && o.type === t)\n          ) {\n            continue;\n          }\n          uniqueTypes.push(\n            t === \"null\" || t === null\n              ? NULL\n              : transformSchemaObject(\n                  { ...schemaObject, type: t, oneOf: undefined } as SchemaObject, // don’t stack oneOf transforms\n                  options,\n                ),\n          );\n        }\n      } else {\n        for (const t of schemaObject.type) {\n          if (t === \"null\" || t === null) {\n            uniqueTypes.push(NULL);\n          } else {\n            uniqueTypes.push(transformSchemaObject({ ...schemaObject, type: t } as SchemaObject, options));\n          }\n        }\n      }\n      return tsUnion(uniqueTypes);\n    }\n  }\n\n  // type: object\n  const coreObjectType: ts.TypeElement[] = [];\n\n  // discriminators: explicit mapping on schema object\n  for (const k of [\"allOf\", \"anyOf\"] as const) {\n    if (!schemaObject[k]) {\n      continue;\n    }\n    // for all magic inheritance, we will have already gathered it into\n    // ctx.discriminators. But stop objects from referencing their own\n    // discriminator meant for children (!schemaObject.discriminator)\n    // and don't add discriminator properties if we already added/patched\n    // them (options.ctx.discriminators.refsHandled.includes(options.path!).\n    const discriminator =\n      !schemaObject.discriminator &&\n      !options.ctx.discriminators.refsHandled.includes(options.path ?? \"\") &&\n      options.ctx.discriminators.objects[options.path ?? \"\"];\n    if (discriminator) {\n      coreObjectType.unshift(\n        createDiscriminatorProperty(discriminator, {\n          path: options.path ?? \"\",\n          readonly: options.ctx.immutable,\n        }),\n      );\n      break;\n    }\n  }\n\n  if (\n    (\"properties\" in schemaObject && schemaObject.properties && Object.keys(schemaObject.properties).length) ||\n    (\"additionalProperties\" in schemaObject && schemaObject.additionalProperties) ||\n    (\"$defs\" in schemaObject && schemaObject.$defs)\n  ) {\n    // properties\n    if (Object.keys(schemaObject.properties ?? {}).length) {\n      for (const [k, v] of getEntries(schemaObject.properties ?? {}, options.ctx)) {\n        if ((typeof v !== \"object\" && typeof v !== \"boolean\") || Array.isArray(v)) {\n          throw new Error(\n            `${options.path}: invalid property ${k}. Expected Schema Object or boolean, got ${\n              Array.isArray(v) ? \"Array\" : typeof v\n            }`,\n          );\n        }\n\n        const { $ref, readOnly, hasDefault } =\n          typeof v === \"object\"\n            ? {\n                $ref: \"$ref\" in v && v.$ref,\n                readOnly: \"readOnly\" in v && v.readOnly,\n                hasDefault: \"default\" in v && v.default !== undefined,\n              }\n            : {};\n\n        // handle excludeDeprecated option\n        if (options.ctx.excludeDeprecated) {\n          const resolved = $ref ? options.ctx.resolve<SchemaObject>($ref) : v;\n          if ((resolved as SchemaObject)?.deprecated) {\n            continue;\n          }\n        }\n        let optional =\n          schemaObject.required?.includes(k) ||\n          (schemaObject.required === undefined && options.ctx.propertiesRequiredByDefault) ||\n          (hasDefault &&\n            options.ctx.defaultNonNullable &&\n            !options.path?.includes(\"parameters\") &&\n            !options.path?.includes(\"requestBody\") &&\n            !options.path?.includes(\"requestBodies\")) // can’t be required, even with defaults\n            ? undefined\n            : QUESTION_TOKEN;\n        let type = $ref\n          ? oapiRef($ref)\n          : transformSchemaObject(v, {\n              ...options,\n              path: createRef([options.path, k]),\n            });\n\n        if (typeof options.ctx.transform === \"function\") {\n          const result = options.ctx.transform(v as SchemaObject, options);\n          if (result && typeof result === \"object\") {\n            if (\"schema\" in result) {\n              type = result.schema;\n              optional = result.questionToken ? QUESTION_TOKEN : optional;\n            } else {\n              type = result;\n            }\n          }\n        }\n\n        const property = ts.factory.createPropertySignature(\n          /* modifiers     */ tsModifiers({\n            readonly: options.ctx.immutable || readOnly,\n          }),\n          /* name          */ tsPropertyIndex(k),\n          /* questionToken */ optional,\n          /* type          */ type,\n        );\n        addJSDocComment(v, property);\n        coreObjectType.push(property);\n      }\n    }\n\n    // $defs\n    if (schemaObject.$defs && typeof schemaObject.$defs === \"object\" && Object.keys(schemaObject.$defs).length) {\n      const defKeys: ts.TypeElement[] = [];\n      for (const [k, v] of Object.entries(schemaObject.$defs)) {\n        const property = ts.factory.createPropertySignature(\n          /* modifiers    */ tsModifiers({\n            readonly: options.ctx.immutable || (\"readonly\" in v && !!v.readOnly),\n          }),\n          /* name          */ tsPropertyIndex(k),\n          /* questionToken */ undefined,\n          /* type          */ transformSchemaObject(v, {\n            ...options,\n            path: createRef([options.path, \"$defs\", k]),\n          }),\n        );\n        addJSDocComment(v, property);\n        defKeys.push(property);\n      }\n      coreObjectType.push(\n        ts.factory.createPropertySignature(\n          /* modifiers     */ undefined,\n          /* name          */ tsPropertyIndex(\"$defs\"),\n          /* questionToken */ undefined,\n          /* type          */ ts.factory.createTypeLiteralNode(defKeys),\n        ),\n      );\n    }\n\n    // additionalProperties\n    if (schemaObject.additionalProperties || options.ctx.additionalProperties) {\n      const hasExplicitAdditionalProperties =\n        typeof schemaObject.additionalProperties === \"object\" && Object.keys(schemaObject.additionalProperties).length;\n      const addlType = hasExplicitAdditionalProperties\n        ? transformSchemaObject(schemaObject.additionalProperties as SchemaObject, options)\n        : UNKNOWN;\n      return tsIntersection([\n        ...(coreObjectType.length ? [ts.factory.createTypeLiteralNode(coreObjectType)] : []),\n        ts.factory.createTypeLiteralNode([\n          ts.factory.createIndexSignature(\n            /* modifiers  */ tsModifiers({\n              readonly: options.ctx.immutable,\n            }),\n            /* parameters */ [\n              ts.factory.createParameterDeclaration(\n                /* modifiers      */ undefined,\n                /* dotDotDotToken */ undefined,\n                /* name           */ ts.factory.createIdentifier(\"key\"),\n                /* questionToken  */ undefined,\n                /* type           */ STRING,\n              ),\n            ],\n            /* type       */ addlType,\n          ),\n        ]),\n      ]);\n    }\n  }\n\n  return coreObjectType.length ? ts.factory.createTypeLiteralNode(coreObjectType) : undefined;\n}\n\n/**\n * Check if an object has a key\n * @param possibleObject - The object to check\n * @param key - The key to check for\n * @returns True if the object has the key, false otherwise\n */\nfunction hasKey<K extends string>(possibleObject: unknown, key: K): possibleObject is { [key in K]: unknown } {\n  return typeof possibleObject === \"object\" && possibleObject !== null && key in possibleObject;\n}\n"],"names":["enumType"],"mappings":"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"}
diff --git a/src/transform/schema-object.ts b/src/transform/schema-object.ts
index 9c572512609561a144786b8f8773342e9499cdfb..ff45986e1f41de3a034cb9cfb8d040e598f5247a 100644
--- a/src/transform/schema-object.ts
+++ b/src/transform/schema-object.ts
@@ -100,9 +100,17 @@ export function transformSchemaObjectWithComposition(
       options.ctx.enum &&
       schemaObject.enum.every((v) => typeof v === "string" || typeof v === "number" || v === null)
     ) {
-      let enumName = parseRef(options.path ?? "").pointer.join("/");
-      // allow #/components/schemas to have simpler names
-      enumName = enumName.replace("components/schemas", "");
+      const enumName = (() => {
+        // specific to codebloom, is a requirement in regards to [509](https://codebloom.notion.site/Fix-enum-2c37c85563aa807e91ddd0ddf7937cc7)
+        if (schemaObject.description) {
+          return schemaObject.description;
+        }
+
+        let n = parseRef(options.path ?? "").pointer.join("/");
+        // allow #/components/schemas to have simpler names
+        n = n.replace("components/schemas", "");
+        return n;
+      })();
       const metadata = schemaObject.enum.map((_, i) => ({
         name: schemaObject["x-enum-varnames"]?.[i] ?? schemaObject["x-enumNames"]?.[i],
         description: schemaObject["x-enum-descriptions"]?.[i] ?? schemaObject["x-enumDescriptions"]?.[i],
